1)import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import { API_URL } from '../config'; // Ensure this is set correctly

interface User {
  id: string;
  email: string;
  username?: string;
  user_type: 'patient' | 'therapist' | ''; // This is already correct
  // ... other user properties
}

interface AuthState {
  accessToken: string | null;
  refreshToken: string | null;
  isLoading: boolean;
}

interface AuthContextType extends AuthState {
  user: User | null;
  signIn: (tokens: { access: string; refresh: string }) => Promise<void>;
  signOut: () => Promise<void>;
  updateTokens: (tokens: { access: string; refresh?: string }) => Promise<void>;
  updateUserRole: (role: 'patient' | 'therapist') => Promise<void>;
  fetchUserData: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [authState, setAuthState] = useState<AuthState>({
    accessToken: null,
    refreshToken: null,
    isLoading: true,
  });

  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    loadStoredTokens();
  }, []);

  const fetchUserData = async () => {
    if (!authState.accessToken) return;
    
    try {
      // Ensure the endpoint exactly matches your backend (trailing slash if required)
      const response = await axios.get(`${API_URL}/users/me/`, {
        headers: {
          Authorization: `Bearer ${authState.accessToken}`
        }
      });
      
      setUser(response.data as User);
      await AsyncStorage.setItem('userData', JSON.stringify(response.data));
    } catch (error) {
      console.error('Error fetching user data:', error);
      // Optionally handle error (for example, force logout if token is invalid)
    }
  };

  const loadStoredTokens = async () => {
    try {
      const [accessToken, refreshToken, userData] = await Promise.all([
        AsyncStorage.getItem('accessToken'),
        AsyncStorage.getItem('refreshToken'),
        AsyncStorage.getItem('userData'),
      ]);

      if (accessToken) {
        setAuthState({
          accessToken,
          refreshToken,
          isLoading: false,
        });
        
        if (userData) {
          setUser(JSON.parse(userData));
        }
        
        setupAxiosInterceptor(accessToken);
        // Fetch fresh user data in the background
        fetchUserData();
      } else {
        setAuthState(prev => ({ ...prev, isLoading: false }));
      }
    } catch (error) {
      console.error('Error loading auth tokens:', error);
      setAuthState(prev => ({ ...prev, isLoading: false }));
    }
  };

  const setupAxiosInterceptor = (token: string) => {
    axios.interceptors.request.use(
      (config) => {
        if (token) {
          config.headers = config.headers || {};
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
  };

  const signIn = async (tokens: { access: string; refresh: string }) => {
    try {
      // Store tokens locally
      await AsyncStorage.multiSet([
        ['accessToken', tokens.access],
        ['refreshToken', tokens.refresh],
      ]);

      // Update state with tokens before making API call
      setAuthState({
        accessToken: tokens.access,
        refreshToken: tokens.refresh,
        isLoading: false,
      });

      // Setup axios interceptor
      setupAxiosInterceptor(tokens.access);

      // Try to fetch user data with retry logic
      let retryCount = 0;
      const maxRetries = 3;
      let userData: User | null = null;

      while (retryCount < maxRetries) {
        try {
          // Add delay between retries (increasing with each retry)
          if (retryCount > 0) {
            await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
          }

          // Fetch user data
          const response = await axios.get(`${API_URL}/users/me/`, {
            headers: {
              Authorization: `Bearer ${tokens.access}`,
            },
          });

          userData = response.data as User;
          break; // Success - exit the retry loop
        } catch (error: any) {
          if (error.response?.status === 429) {
            console.log(`Rate limited (429). Retry attempt ${retryCount + 1} of ${maxRetries}`);
            retryCount++;
            
            if (retryCount >= maxRetries) {
              console.warn('Max retries reached for fetching user data');
              // Continue with sign-in but set partial user state
              userData = { 
                id: '', 
                email: '',
                user_type: ''
              } as User;
            }
          } else {
            // For non-rate limit errors, propagate the error
            throw error;
          }
        }
      }

      // Set user state if we have data
      if (userData) {
        // Ensure the user_type is one of the valid types
        const validUserType = 
          userData.user_type === 'patient' || 
          userData.user_type === 'therapist' || 
          userData.user_type === '';

        if (!validUserType) {
          console.warn(`Received invalid user_type: ${userData.user_type}. Setting to empty string.`);
          userData.user_type = '';
        }
        
        setUser(userData);
        await AsyncStorage.setItem('userData', JSON.stringify(userData));
      }

      // Schedule a retry to fetch complete user data in the background after some delay
      if (retryCount >= maxRetries) {
        setTimeout(() => fetchUserData(), 5000);
      }
    } catch (error: any) {
      console.error('Error during sign in:', error);
      throw error;
    }
  };

  const signOut = async () => {
    try {
      await AsyncStorage.multiRemove(['accessToken', 'refreshToken', 'userData']);
      setAuthState({
        accessToken: null,
        refreshToken: null,
        isLoading: false,
      });
      setUser(null);
    } catch (error) {
      console.error('Error removing auth tokens:', error);
      throw error;
    }
  };

  const updateTokens = async (tokens: { access: string; refresh?: string }) => {
    try {
      const updates: [string, string][] = [['accessToken', tokens.access]];
      if (tokens.refresh) {
        updates.push(['refreshToken', tokens.refresh]);
      }

      await AsyncStorage.multiSet(updates);
      setAuthState(prev => ({
        ...prev,
        accessToken: tokens.access,
        refreshToken: tokens.refresh ?? prev.refreshToken,
      }));

      setupAxiosInterceptor(tokens.access);
    } catch (error) {
      console.error('Error updating tokens:', error);
      throw error;
    }
  };

  const updateUserRole = async (role: 'patient' | 'therapist') => {
    try {
      // Update the user state immediately for a better UX
      // Use type assertion to ensure TypeScript understands this is a valid assignment
      setUser(prev => {
        if (!prev) return null;
        
        // Create a new user object with the updated role
        return {
          ...prev,
          user_type: role as 'patient' | 'therapist' // Explicitly cast to allowed type
        };
      });

      // Then update the backend
      await axios.post(
        `${API_URL}/users/set-user-type/`,
        { user_type: role },
        {
          headers: {
            Authorization: `Bearer ${authState.accessToken}`
          }
        }
      );
      
      // After successful update, refresh user data to ensure it's in sync
      await fetchUserData();
    } catch (error) {
      console.error('Error updating user role:', error);
      throw error;
    }
  };

  return (
    <AuthContext.Provider
      value={{
        accessToken: authState.accessToken,
        refreshToken: authState.refreshToken,
        isLoading: authState.isLoading,
        user,
        signIn,
        signOut,
        updateTokens,
        updateUserRole,
        fetchUserData,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
2)//screens/auth/ForgetPasswordScreen.tsx
import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Alert,
} from "react-native";
import { NavigationProp } from "@react-navigation/native";
import Icon from "react-native-vector-icons/FontAwesome";
import Logo from "../../assets/images/logo_mindcare.svg";
import { gsap } from 'gsap';

type ForgotPasswordScreenProps = {
  navigation: NavigationProp<any>;
};

const ForgotPasswordScreen = ({ navigation }: ForgotPasswordScreenProps) => {
  const [email, setEmail] = useState("");
  const [isEmailValid, setIsEmailValid] = useState<boolean | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [showResetInstructions, setShowResetInstructions] = useState(false);
  
  const formRef = useRef(null);
  const logoRef = useRef(null);
  const titleRef = useRef(null);

  // Add initial animation
  useEffect(() => {
    const tl = gsap.timeline();
    
    tl.from(logoRef.current, {
      y: -30,
      opacity: 0,
      duration: 0.8,
      ease: "power3.out"
    })
    .from(formRef.current, {
      y: 30,
      opacity: 0,
      duration: 0.6,
      ease: "power2.out"
    }, "-=0.4")
    .from(titleRef.current, {
      scale: 0.9,
      opacity: 0,
      duration: 0.4,
      ease: "back.out"
    }, "-=0.3");
  }, []);

  const validateEmail = (email: string) => {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  };

  const handleChange = (value: string) => {
    setEmail(value);
    
    if (value.length > 0) {
      setIsEmailValid(validateEmail(value));
    } else {
      setIsEmailValid(null);
    }
    
    // Clear any messages when user starts typing again
    if (error) setError(null);
    if (successMessage) {
      setSuccessMessage(null);
      setShowResetInstructions(false);
    }
  };

  // Replace shakeError with GSAP version
  const shakeError = () => {
    gsap.to(formRef.current, {
      x: 10,
      duration: 0.1,
      repeat: 3,
      yoyo: true,
      ease: "power2.inOut"
    });
  };

  const handleSendResetLink = async () => {
    // Check for empty email
    if (!email) {
      setError("Please enter your email address");
      shakeError();
      return;
    }
  
    // Check email format
    if (!validateEmail(email)) {
      setError("Please enter a valid email address");
      shakeError();
      return;
    }
  
    try {
      // Add button press animation
      gsap.to(formRef.current, {
        scale: 0.98,
        duration: 0.1,
        yoyo: true,
        repeat: 1
      });

      const response = await fetch("http://127.0.0.1:8000/api/v1/auth/password/reset/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      console.log("Response status:", response.status);

      if (response.ok) {
        // Success animation
        gsap.to(formRef.current, {
          y: -10,
          opacity: 0.8,
          duration: 0.3,
          ease: "power2.inOut",
          yoyo: true,
          repeat: 1
        });
        setSuccessMessage("Password reset link sent to your email");
        setShowResetInstructions(true);
      } else {
        const data = await response.json();
        console.log("Response data:", data);
        setError(data.detail || "Failed to send reset link");
        shakeError();
      }
    } catch (error) {
      console.error("Error:", error);
      setError("An error occurred. Please try again.");
      shakeError();
    }
  };

  const handleManualReset = () => {
    navigation.navigate("ManualResetEntry");
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <View ref={logoRef} style={styles.logoContainer}>
          <Logo width={120} height={120} />
          <Text style={styles.logoText}>MindCare AI</Text>
        </View>

        <View ref={formRef} style={styles.formContainer}>
          <Text ref={titleRef} style={styles.title}>Forgot Password</Text>
          <Text style={styles.subtitle}>
            Enter your email and we'll send you a link to reset your password
          </Text>

          <View style={styles.inputContainer}>
            <TextInput
              style={[styles.input, error && styles.inputError]}
              placeholder="Email Address"
              placeholderTextColor="#888888"
              keyboardType="email-address"
              value={email}
              onChangeText={handleChange}
            />
            {isEmailValid !== null && (
              <Icon
                name={isEmailValid ? "check" : "times"}
                size={20}
                color={isEmailValid ? "#27AE60" : "#E74C3C"}
                style={styles.inputIcon}
              />
            )}
          </View>

          {error && <Text style={styles.errorText}>{error}</Text>}
          {successMessage && <Text style={styles.successText}>{successMessage}</Text>}
          
          {showResetInstructions && (
            <View style={styles.instructionsContainer}>
              <Text style={styles.instructionsText}>
                1. Check your email inbox for the reset link
              </Text>
              <Text style={styles.instructionsText}>
                2. Open the link and copy the UID and token values from the URL
              </Text>
              <Text style={styles.instructionsText}>
                3. Return to this app to complete the password reset
              </Text>
              <TouchableOpacity 
                style={styles.manualResetButton} 
                onPress={() => navigation.navigate("SetNewPassword", { uid: "", token: "" })}
              >
                <Text style={styles.manualResetButtonText}>Enter Reset Information</Text>
              </TouchableOpacity>
            </View>
          )}

          {!showResetInstructions && (
            <TouchableOpacity style={styles.button} onPress={handleSendResetLink}>
              <Text style={styles.buttonText}>SEND RESET LINK</Text>
            </TouchableOpacity>
          )}

          <TouchableOpacity onPress={() => navigation.navigate("Login")}>
            <Text style={styles.backToLogin}>Back to Login</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#E4F0F6",
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
  },
  logoContainer: {
    alignItems: "center",
    marginTop: 40,
    marginBottom: 30,
  },
  logoText: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#002D62",
    marginTop: 10,
  },
  formContainer: {
    backgroundColor: "#fff",
    padding: 20,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 3,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#002D62",
    marginBottom: 10,
    textAlign: "center",
  },
  subtitle: {
    fontSize: 14,
    color: "#666",
    marginBottom: 20,
    textAlign: "center",
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15,
    backgroundColor: "#FFFFFF",
    borderWidth: 1,
    borderColor: "#CFCFCF",
    borderRadius: 10,
  },
  input: {
    flex: 1,
    height: 50,
    paddingHorizontal: 16,
    fontSize: 16,
    color: "#333",
  },
  inputIcon: {
    padding: 10,
  },
  inputError: {
    borderColor: "#E74C3C",
  },
  errorText: {
    color: "#E74C3C",
    fontSize: 14,
    marginBottom: 15,
    textAlign: "center",
  },
  successText: {
    color: "#27AE60",
    fontSize: 14,
    marginBottom: 15,
    textAlign: "center",
  },
  instructionsContainer: {
    marginTop: 20,
  },
  instructionsText: {
    fontSize: 14,
    color: "#666",
    marginBottom: 10,
  },
  manualResetButton: {
    backgroundColor: "#002D62",
    padding: 10,
    borderRadius: 5,
    alignItems: "center",
    marginTop: 10,
  },
  manualResetButtonText: {
    color: "#fff",
    fontSize: 14,
  },
  button: {
    width: "100%",
    backgroundColor: "#002D62",
    padding: 15,
    borderRadius: 10,
    alignItems: "center",
    elevation: 3,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
  },
  buttonText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
  },
  backToLogin: {
    color: "#002D62",
    textAlign: "center",
    marginTop: 20,
    fontSize: 14,
  },
});

export default ForgotPasswordScreen;
3)import React, { useEffect, useRef } from 'react';
import { Linking, View, Text, ActivityIndicator, StyleSheet, Alert } from 'react-native';
import { NavigationProp, useNavigation } from '@react-navigation/native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { gsap } from 'gsap';
import { RootStackParamList } from '../../types/navigation';
import { API_BASE_URL } from '../../config';
import { OAUTH_CONFIG } from '../../config/oauth';

const GoogleCallbackScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const containerRef = useRef(null);
  const loadingRef = useRef(null);
  const textRef = useRef(null);

  // Add initial animation
  useEffect(() => {
    const tl = gsap.timeline();
    
    tl.from(containerRef.current, {
      opacity: 0,
      duration: 0.5,
      ease: "power2.inOut"
    })
    .from(loadingRef.current, {
      scale: 0.5,
      opacity: 0,
      duration: 0.4,
      ease: "back.out"
    })
    .from(textRef.current, {
      y: 20,
      opacity: 0,
      duration: 0.3,
      ease: "power2.out"
    }, "-=0.2");
  }, []);

  useEffect(() => {
    const handleDeepLink = async ({ url }: { url: string }) => {
      if (url.includes('oauth_callback')) {
        try {
          // Parse callback parameters
          const params = new URLSearchParams(url.split('?')[1]);
          const code = params.get('code');
          const state = params.get('state');
          const storedState = await AsyncStorage.getItem('oauth_state');
          const error = params.get('error');

          // Check for OAuth errors
          if (error) {
            throw new Error(`OAuth error: ${error}`);
          }

          // Validate parameters
          if (!code || !state) {
            throw new Error('Missing required OAuth parameters');
          }

          // Verify state to prevent CSRF
          if (state !== storedState) {
            throw new Error('Invalid state parameter');
          }

          // Exchange code for tokens
          const response = await fetch(`${API_BASE_URL}/api/v1/auth/login/google/callback/`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({ 
              code,
              state,
              redirect_uri: OAUTH_CONFIG.googleAuth.redirectUri
            })
          });

          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.detail || 'Authentication failed');
          }

          const data = await response.json();

          // Store tokens securely
          await AsyncStorage.multiSet([
            ['accessToken', data.access],
            ['refreshToken', data.refresh]
          ]);

          // Add success animation before navigation
          gsap.to([loadingRef.current, textRef.current], {
            y: -20,
            opacity: 0,
            duration: 0.4,
            ease: "power2.in",
            stagger: 0.1,
            onComplete: () => {
              navigation.reset({
                index: 0,
                routes: [{ 
                  name: 'App',
                  params: { screen: 'Welcome' }
                }]
              });
            }
          });
        } catch (error) {
          // Add error animation
          gsap.to([loadingRef.current, textRef.current], {
            scale: 0.9,
            opacity: 0,
            duration: 0.3,
            ease: "power2.in",
            onComplete: () => {
              console.error('OAuth callback error:', error);
              Alert.alert(
                'Authentication Error',
                'Failed to complete authentication. Please try again.'
              );
              navigation.navigate('Auth', { screen: 'Login' });
            }
          });
        } finally {
          await AsyncStorage.removeItem('oauth_state');
        }
      }
    };

    Linking.addEventListener('url', handleDeepLink);
    return () => Linking.removeAllListeners('url');
  }, [navigation]);

  return (
    <View ref={containerRef} style={styles.container}>
      <View ref={loadingRef}>
        <ActivityIndicator size="large" color="#002D62" />
      </View>
      <Text ref={textRef} style={styles.text}>
        Completing Google Sign In...
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#E4F0F6',
  },
  text: {
    marginTop: 20,
    fontSize: 16,
    color: '#002D62',
    opacity: 0.9,
  },
});

export default GoogleCallbackScreen;
4)// LoginScreen.tsx
import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Animated,
  Alert,
  Linking,
} from "react-native";
import { NavigationProp, CommonActions } from "@react-navigation/native";
import { RootStackParamList } from "../../types/navigation"; 
import AsyncStorage from "@react-native-async-storage/async-storage";
import Icon from "react-native-vector-icons/FontAwesome";
import Logo from "../../assets/images/logo_mindcare.svg";
import { API_BASE_URL, SOCIAL_LOGIN_URLS, GOOGLE_CLIENT_ID, GITHUB_CLIENT_ID, OAUTH_CONFIG } from "../../config";
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
import { useAuth } from '../../contexts/AuthContext';
import { gsap } from 'gsap';
import { resetOnboardingStatus } from '../../utils/onboarding';
import { setCachedToken } from '../../utils/auth';

type LoginScreenProps = {
  navigation: NavigationProp<RootStackParamList>;
};

const LoginScreen = ({ navigation }: LoginScreenProps) => {
  const [formData, setFormData] = useState({
    email: "",
    password: "",
  });
  const [showPassword, setShowPassword] = useState(false);
  const [isEmailValid, setIsEmailValid] = useState<boolean | null>(null);
  const [loginError, setLoginError] = useState<string | null>(null);

  const shakeAnimation = useRef(new Animated.Value(0)).current;
  const { signIn } = useAuth();

  const logoRef = useRef<View | null>(null);
  const formRef = useRef<View | null>(null);
  const socialButtonsRef = useRef<View | null>(null);

  useEffect(() => {
    // Log all available route names for debugging
    try {
      const state = navigation.getState();
      console.log("Available routes in this navigator:", state.routeNames);
      
      // Also log the current navigation state
      console.log("Current navigation state:", JSON.stringify(state, null, 2));
    } catch (error) {
      console.error("Error inspecting navigation:", error);
    }
  }, [navigation]);

  useEffect(() => {
    // Initial animation timeline
    const tl = gsap.timeline();
    
    tl.from(logoRef.current, {
      y: -50,
      opacity: 0,
      duration: 1,
      ease: "power3.out"
    })
    .from(formRef.current, {
      y: 30,
      opacity: 0,
      duration: 0.8,
      ease: "power2.out"
    }, "-=0.5");
    // Remove or comment out the following tween since React Native does not use traditional CSS selectors
    // .from('.socialButton', {
    //   y: 20,
    //   opacity: 0,
    //   duration: 0.4,
    //   stagger: 0.1,
    //   ease: "power2.out"
    // }, "-=0.3");
  }, []);

  const validateEmail = (email: string) => {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  };

  const handleChange = (field: string, value: string) => {
    setFormData({
      ...formData,
      [field]: value,
    });

    if (field === "email") {
      if (value.length > 0) {
        setIsEmailValid(validateEmail(value));
      } else {
        setIsEmailValid(null);
      }
    }

    // Clear any error when user starts typing again
    if (loginError) setLoginError(null);
  };

  const shakeError = () => {
    gsap.to(formRef.current, {
      x: 10,
      duration: 0.1,
      repeat: 3,
      yoyo: true,
      ease: "power2.inOut"
    });
  };

  // Check if the user has seen the onboarding
  const checkAndNavigate = async (userProfile?: any) => {
    try {
      console.log("Navigating with profile:", userProfile);
      
      // If user_type is empty or undefined, always show onboarding
      if (!userProfile?.user_type || userProfile.user_type.trim() === "") {
        console.log("User has no user_type, navigating to onboarding");
        
        // Reset the onboarding flag first
        await resetOnboardingStatus();
        
        // Based on your navigation output logs and the error message,
        // it seems Onboarding is likely in the root stack, not the Auth stack
        navigation.dispatch(
          CommonActions.reset({
            index: 0,
            routes: [{ name: 'Onboarding' }],
          })
        );
        
        return;
      }
      
      // For users with a user_type
      console.log("User has user_type:", userProfile.user_type, "going to Home");
      navigation.dispatch(
        CommonActions.reset({
          index: 0,
          routes: [{
            name: 'App',
            params: { screen: 'Home' }
          }],
        })
      );
    } catch (error) {
      console.error("Error in navigation:", error);
      Alert.alert(
        'Navigation Error',
        'An error occurred during login navigation. Please check logs.'
      );
    }
  };

  const handleLoginAsync = async () => {
    if (!formData.email || !formData.password) {
      setLoginError("Please fill in all fields.");
      shakeError();
      return;
    }

    if (!validateEmail(formData.email)) {
      setLoginError("Please enter a valid email address.");
      shakeError();
      return;
    }

    try {
      // Animate button press
      gsap.to(formRef.current, {
        scale: 0.98,
        duration: 0.1,
        yoyo: true,
        repeat: 1
      });

      console.log("Login data:", { email: formData.email, password: formData.password });
      
      const response = await fetch(`${API_BASE_URL}/api/v1/auth/login/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: formData.email,
          password: formData.password,
        }),
      });

      const data = await response.json();
      console.log("Login response:", data);

      if (response.ok) {
        // Success animation
        gsap.to(formRef.current, {
          y: -20,
          opacity: 0,
          duration: 0.5,
          ease: "power2.in",
          onComplete: () => {
            // Execute async operations after animation completes
            (async () => {
              await signIn({
                access: data.access,
                refresh: data.refresh,
              });
              // Cache the access token synchronously for use in WebSocket connection, etc.
              setCachedToken(data.access);
              
              try {
                const profileResponse = await fetch(`${API_BASE_URL}/api/v1/users/me/`, {
                  method: "GET",
                  headers: {
                    "Authorization": `Bearer ${data.access}`,
                    "Content-Type": "application/json"
                  }
                });
                const profileData = await profileResponse.json();
                console.log("User profile:", profileData);
                // Pass profileData so that checkAndNavigate can test user_type
                checkAndNavigate(profileData);
              } catch (profileError) {
                console.error("Error fetching user profile:", profileError);
                // In case of error, you can decide what to do (default to onboarding, for example)
                checkAndNavigate();
              }
            })();
          }
        });
      } else {
        setLoginError(data.detail || "Invalid email or password.");
        shakeError();
      }
    } catch (error) {
      console.error("Login error:", error);
      setLoginError("An error occurred during login. Please try again.");
      shakeError();
    }
  };

  // Synchronous wrapper function
  const handleLogin = () => {
    handleLoginAsync().catch(err => {
      console.error("Unhandled login error:", err);
    });
  };

  const handleGoogleLogin = async () => {
    try {
      // Generate secure state
      const state = uuidv4().replace(/-/g, '');
      await AsyncStorage.setItem('oauth_state', state);

      const params = new URLSearchParams({
        client_id: GOOGLE_CLIENT_ID,
        redirect_uri: OAUTH_CONFIG.redirectUri,
        response_type: 'code',
        scope: 'openid email profile',
        state: state,
        access_type: 'offline',
        prompt: 'consent'
      });

      const googleAuthUrl = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
      await Linking.openURL(googleAuthUrl);
    } catch (error) {
      console.error('Google login error:', error);
      Alert.alert('Error', 'Failed to initiate Google sign in');
    }
  };

  const handleGithubLogin = async () => {
    try {
      // Generate secure state for CSRF protection
      const state = uuidv4().replace(/-/g, '');
      await AsyncStorage.setItem('oauth_state', state);

      // Construct GitHub OAuth URL with correct redirect URI
      const params = new URLSearchParams({
        client_id: GITHUB_CLIENT_ID,
        redirect_uri: 'com.mindcareai.app:/oauth2redirect',
        scope: OAUTH_CONFIG.githubAuth.scope,
        state: state,
        allow_signup: OAUTH_CONFIG.githubAuth.allowSignup.toString()
      });

      const githubAuthUrl = `https://github.com/login/oauth/authorize?${params}`;
      await Linking.openURL(githubAuthUrl);
    } catch (error) {
      console.error('GitHub login error:', error);
      Alert.alert(
        'Login Error',
        'Failed to initiate GitHub login. Please try again.'
      );
    }
  };

  useEffect(() => {
    // Create subscription object to handle cleanup
    let subscription: any;

    const setupDeepLinkHandler = () => {
      subscription = Linking.addEventListener('url', handleDeepLink);
    };

    const handleDeepLink = async ({ url }: { url: string }) => {
      if (url.includes('oauth_callback')) {
        try {
          const params = new URLSearchParams(url.split('?')[1]);
          const code = params.get('code');
          const state = params.get('state');
          const storedState = await AsyncStorage.getItem('oauth_state');

          // Verify state parameter to prevent CSRF attacks
          if (!code || state !== storedState) {
            throw new Error('Invalid authentication response');
          }

          // Determine OAuth provider and handle authentication
          const isGoogle = url.toLowerCase().includes('google');
          const endpoint = isGoogle ? 
            `${API_BASE_URL}/api/v1/auth/login/google/callback/` :
            `${API_BASE_URL}/api/v1/auth/login/github/callback/`;

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ code, state })
          });

          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.detail || 'OAuth login failed');
          }

          // Store tokens atomically
          await AsyncStorage.multiSet([
            ['accessToken', data.access],
            ['refreshToken', data.refresh]
          ]);

          // Fetch user profile before navigating
          try {
            const profileResponse = await fetch(`${API_BASE_URL}/api/v1/users/me/`, {
              method: "GET",
              headers: {
                "Authorization": `Bearer ${data.access}`,
                "Content-Type": "application/json"
              }
            });
            const profileData = await profileResponse.json();
            console.log("OAuth user profile:", profileData);

            // Use signIn from AuthContext to properly set the tokens
            await signIn({
              access: data.access,
              refresh: data.refresh,
            });

            // Check profile and navigate accordingly
            if (!profileData?.user_type || profileData.user_type.trim() === "") {
              console.log("OAuth user has no user_type, navigating to onboarding");
              await resetOnboardingStatus();
              navigation.dispatch(
                CommonActions.reset({
                  index: 0,
                  routes: [{ name: 'Onboarding' }],
                })
              );
            } else {
              console.log("OAuth user has user_type, going to Home");
              navigation.dispatch(
                CommonActions.reset({
                  index: 0,
                  routes: [{
                    name: 'App',
                    params: { screen: 'Home' }
                  }],
                })
              );
            }
          } catch (profileError) {
            console.error("Error fetching OAuth user profile:", profileError);
            // Default to standard checkAndNavigate
            await checkAndNavigate();
          }
        } catch (error) {
          console.error('OAuth callback error:', error);
          Alert.alert(
            'Login Error',
            'Failed to complete authentication. Please try again.'
          );
          navigation.navigate('Auth', { screen: 'Login' });
        } finally {
          await AsyncStorage.removeItem('oauth_state');
        }
      }
    };

    setupDeepLinkHandler();

    // Cleanup function
    return () => {
      if (subscription?.remove) {
        subscription.remove();
      }
    };
  }, [navigation]);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <View ref={logoRef} style={styles.logoContainer}>
          <Logo width={120} height={120} />
          <Text style={styles.logoText}>MindCare AI</Text>
        </View>

        <View ref={formRef} style={styles.loginContainer}>
          <Text style={styles.title}>Sign In</Text>

          <View style={styles.inputContainer}>
            <TextInput
              style={[styles.input, loginError && styles.inputError]}
              placeholder="Email Address"
              placeholderTextColor="#888888"
              keyboardType="email-address"
              value={formData.email}
              onChangeText={(value) => handleChange("email", value)}
            />
            {isEmailValid !== null && (
              <Icon
                name={isEmailValid ? "check" : "times"}
                size={20}
                color={isEmailValid ? "#27AE60" : "#E74C3C"}
                style={styles.inputIcon}
              />
            )}
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={[styles.input, loginError && styles.inputError]}
              placeholder="Password"
              placeholderTextColor="#888888"
              secureTextEntry={!showPassword}
              value={formData.password}
              onChangeText={(value) => handleChange("password", value)}
            />
            <TouchableOpacity
              onPress={() => setShowPassword(!showPassword)}
              style={styles.inputIcon}
            >
              <Icon
                name={showPassword ? "eye-slash" : "eye"}
                size={20}
                color="#888888"
              />
            </TouchableOpacity>
          </View>

          {loginError && <Text style={styles.errorText}>{loginError}</Text>}

          <TouchableOpacity style={styles.loginButton} onPress={handleLogin}>
            <Text style={styles.loginButtonText}>SIGN IN</Text>
          </TouchableOpacity>

          <View ref={socialButtonsRef} style={styles.socialButtonsContainer}>
            <TouchableOpacity 
              style={styles.socialButton}
              onPress={handleGoogleLogin}
            >
              <Icon name="google" size={20} color="#DB4437" />
              <Text style={styles.socialButtonText}>Continue with Google</Text>
            </TouchableOpacity>

            <TouchableOpacity 
              style={styles.socialButton}
              onPress={handleGithubLogin}
            >
              <Icon name="github" size={20} color="#333" />
              <Text style={styles.socialButtonText}>Continue with GitHub</Text>
            </TouchableOpacity>
          </View>

          <TouchableOpacity
            onPress={() => navigation.navigate("Auth", { screen: "ForgotPassword" })}
          >
            <Text style={styles.forgotPassword}>Forgot password?</Text>
          </TouchableOpacity>

          <TouchableOpacity onPress={() => navigation.navigate("Auth", { screen: "Signup" })}>
            <Text style={styles.createAccount}>
              Don't have an account? Sign Up
            </Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  // ... styles remain unchanged
  container: {
    flex: 1,
    backgroundColor: "#E4F0F6",
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
    paddingBottom: 40,
  },
  logoContainer: {
    alignItems: "center",
    marginTop: 40,
    marginBottom: 30,
  },
  logoText: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#002D62",
    marginTop: 10,
    letterSpacing: 0.5,
  },
  loginContainer: {
    backgroundColor: "#fff",
    padding: 24,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 5,
    marginHorizontal: 2,
  },
  title: {
    fontSize: 26,
    fontWeight: "bold",
    color: "#002D62",
    marginBottom: 24,
    textAlign: "center",
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 18,
    backgroundColor: "#FFFFFF",
    borderWidth: 1,
    borderColor: "#CFCFCF",
    borderRadius: 10,
  },
  input: {
    flex: 1,
    height: 54,
    paddingHorizontal: 16,
    fontSize: 16,
    color: "#333",
  },
  inputIcon: {
    padding: 12,
  },
  inputError: {
    borderColor: "#E74C3C",
    borderWidth: 1.5,
  },
  errorText: {
    color: "#E74C3C",
    fontSize: 14,
    marginBottom: 15,
    textAlign: "center",
    fontWeight: "500",
  },
  forgotPassword: {
    color: "#002D62",
    textAlign: "center",
    marginTop: 18,
    fontSize: 15,
    textDecorationLine: "underline",
    fontWeight: "500",
  },
  loginButton: {
    width: "100%",
    backgroundColor: "#002D62",
    padding: 16,
    borderRadius: 10,
    alignItems: "center",
    elevation: 4,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3,
    marginTop: 6,
  },
  loginButtonText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
    letterSpacing: 0.5,
  },
  createAccount: {
    color: "#002D62",
    textAlign: "center",
    marginTop: 22,
    marginBottom: 8,
    fontSize: 15,
    fontWeight: "500",
  },
  socialButtonsContainer: {
    marginTop: 24,
    marginBottom: 4,
    width: '100%',
  },
  socialButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 14,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#CFCFCF',
    marginVertical: 8,
    backgroundColor: '#FFFFFF',
    elevation: 1,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
  },
  socialButtonText: {
    marginLeft: 12,
    color: '#002D62',
    fontWeight: '500',
    fontSize: 16,
  },
});

export default LoginScreen;
5)//screens/auth/SetNewPasswordScreen.tsx
import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Animated,
} from "react-native";
import { StackScreenProps } from '@react-navigation/stack';
import { AuthStackParamList } from "../../types/navigation";
import { gsap } from 'gsap';

type SetNewPasswordScreenProps = StackScreenProps<AuthStackParamList, 'SetNewPassword'>;

const SetNewPasswordScreen: React.FC<SetNewPasswordScreenProps> = ({ route, navigation }) => {
  const { uid, token } = route.params;

  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const formRef = useRef(null);
  const titleRef = useRef(null);

  useEffect(() => {
    // Initial animation timeline
    const tl = gsap.timeline();
    
    tl.from(titleRef.current, {
      y: -30,
      opacity: 0,
      duration: 0.8,
      ease: "power3.out"
    })
    .from(formRef.current, {
      y: 30,
      opacity: 0,
      duration: 0.6,
      ease: "power2.out"
    }, "-=0.4");
  }, []);

  const shakeError = () => {
    gsap.to(formRef.current, {
      x: 10,
      duration: 0.1,
      repeat: 3,
      yoyo: true,
      ease: "power2.inOut"
    });
  };

  const handleSetNewPassword = async () => {
    if (!password || !confirmPassword) {
      setError("Please enter both password fields");
      shakeError();
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      shakeError();
      return;
    }

    try {
      // Add button press animation
      gsap.to(formRef.current, {
        scale: 0.98,
        duration: 0.1,
        yoyo: true,
        repeat: 1
      });

      const response = await fetch("http://127.0.0.1:8000/api/v1/auth/password/reset/confirm/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ uid, token, new_password1: password, new_password2: confirmPassword }),
      });

      if (response.ok) {
        setSuccessMessage("Password reset successful!");
        // Success animation
        gsap.to(formRef.current, {
          y: -20,
          opacity: 0,
          duration: 0.5,
          ease: "power2.in",
          onComplete: () => {
            setTimeout(() => {
              navigation.navigate("Login" as never);
            }, 1000);
          }
        });
      } else {
        const data = await response.json();
        setError(data.detail || "Password reset failed");
        shakeError();
      }
    } catch (error) {
      setError("Network error, please try again.");
      shakeError();
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <Text ref={titleRef} style={styles.title}>Set New Password</Text>
        
        <View ref={formRef} style={styles.formContainer}>
          <TextInput
            style={styles.input}
            placeholder="New Password"
            secureTextEntry
            value={password}
            onChangeText={setPassword}
          />
          <TextInput
            style={styles.input}
            placeholder="Confirm Password"
            secureTextEntry
            value={confirmPassword}
            onChangeText={setConfirmPassword}
          />

          {error && <Text style={styles.errorText}>{error}</Text>}
          {successMessage && <Text style={styles.successText}>{successMessage}</Text>}

          <TouchableOpacity style={styles.button} onPress={handleSetNewPassword}>
            <Text style={styles.buttonText}>Submit</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#E4F0F6" },
  scrollContainer: { flexGrow: 1, padding: 20 },
  formContainer: { backgroundColor: "#fff", padding: 20, borderRadius: 10 },
  title: { fontSize: 24, fontWeight: "bold", textAlign: "center", marginBottom: 20 },
  input: { height: 50, borderWidth: 1, paddingHorizontal: 10, marginBottom: 10 },
  errorText: { color: "red", textAlign: "center", marginBottom: 10 },
  successText: { color: "green", textAlign: "center", marginBottom: 10 },
  button: { backgroundColor: "#002D62", padding: 15, borderRadius: 10, alignItems: "center" },
  buttonText: { color: "#fff", fontSize: 16, fontWeight: "bold" },
});

export default SetNewPasswordScreen;

6)import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Animated,
} from "react-native";
import { NavigationProp } from "@react-navigation/native";
import Icon from "react-native-vector-icons/FontAwesome";
import Logo from "../../assets/images/logo_mindcare.svg";
import { gsap } from 'gsap';

type SignupScreenProps = {
  navigation: NavigationProp<any>;
};

const SignupScreen = ({ navigation }: SignupScreenProps) => {
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    password1: "",
    password2: "",
    first_name: "",
    last_name: "",
  });
  const [showPassword1, setShowPassword1] = useState(false);
  const [showPassword2, setShowPassword2] = useState(false);
  const [isEmailValid, setIsEmailValid] = useState<boolean | null>(null);
  const [signupError, setSignupError] = useState<string | null>(null);

  const shakeAnimation = useRef(new Animated.Value(0)).current;
  const logoRef = useRef(null);
  const formRef = useRef(null);
  
  useEffect(() => {
    // Initial animation timeline
    const tl = gsap.timeline();
    
    tl.from(logoRef.current, {
      y: -50,
      opacity: 0,
      duration: 1,
      ease: "power3.out"
    })
    .from(formRef.current, {
      y: 30,
      opacity: 0,
      duration: 0.8,
      ease: "power2.out"
    }, "-=0.5");
  }, []);

  const validateEmail = (email: string) => {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(email);
  };

  const validatePassword = (password: string) => {
    // At least 8 characters
    const minLength = password.length >= 8;
    // At least one uppercase letter
    const hasUpperCase = /[A-Z]/.test(password);
    // At least one lowercase letter
    const hasLowerCase = /[a-z]/.test(password);
    // At least one number
    const hasNumber = /\d/.test(password);
    // At least one special character
    const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);

    return minLength && hasUpperCase && hasLowerCase && hasNumber && hasSpecial;
  };

  const handleChange = (field: string, value: string) => {
    setFormData({
      ...formData,
      [field]: value,
    });

    if (field === "email") {
      if (value.length > 0) {
        setIsEmailValid(validateEmail(value));
      } else {
        setIsEmailValid(null);
      }
    }

    // Clear any error when user starts typing again
    if (signupError) setSignupError(null);
  };

  // Replace the existing shakeError function with this GSAP version
  const shakeError = () => {
    gsap.to(formRef.current, {
      x: 10,
      duration: 0.1,
      repeat: 3,
      yoyo: true,
      ease: "power2.inOut"
    });
  };

  const handleSignup = async () => {
    console.log("Form data:", formData);

    // Basic validation
    if (
      !formData.username ||
      !formData.email ||
      !formData.password1 ||
      !formData.password2 ||
      !formData.first_name ||
      !formData.last_name
    ) {
      setSignupError("Please fill in all fields");
      shakeError();
      return;
    }

    // Email validation
    if (!validateEmail(formData.email)) {
      setSignupError("Please enter a valid email address");
      shakeError();
      return;
    }

    // Add password validation check
    if (!validatePassword(formData.password1)) {
      setSignupError(
        "Password must be at least 8 characters and contain uppercase, lowercase, number and special characters"
      );
      shakeError();
      return;
    }

    // Password matching
    if (formData.password1 !== formData.password2) {
      setSignupError("Passwords do not match");
      shakeError();
      return;
    }

    // Prepare payload as expected by the backend's CustomRegisterSerializer
    const payload = {
      username: formData.username,
      email: formData.email,
      first_name: formData.first_name,
      last_name: formData.last_name,
      password1: formData.password1,
      password2: formData.password2,
    };

    try {
      // Add button press animation
      gsap.to(formRef.current, {
        scale: 0.98,
        duration: 0.1,
        yoyo: true,
        repeat: 1
      });

      const response = await fetch("http://127.0.0.1:8000/api/v1/auth/register/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await response.json();

      if (response.ok) {
        console.log("Signup success:", data);
        // Success animation
        gsap.to(formRef.current, {
          y: -20,
          opacity: 0,
          duration: 0.5,
          ease: "power2.in",
          onComplete: () => {
            navigation.navigate("Login");
          }
        });
      } else {
        console.error("Signup error details:", data);
        setSignupError(
          data.detail ||
            data.email ||
            data.username ||
            "Signup failed"
        );
        shakeError();
      }
    } catch (error) {
      console.error("Network error during signup:", error);
      setSignupError("Network error, please try again");
      shakeError();
    }
  };

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollContainer}>
        <View ref={logoRef} style={styles.logoContainer}>
          <Logo width={120} height={120} />
          <Text style={styles.logoText}>MindCare AI</Text>
        </View>

        <View 
          ref={formRef} 
          style={styles.signupContainer}
        >
          <Text style={styles.title}>Create Your Account</Text>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="Username"
              placeholderTextColor="#888888"
              value={formData.username}
              onChangeText={(value) => handleChange("username", value)}
            />
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="Email"
              placeholderTextColor="#888888"
              keyboardType="email-address"
              value={formData.email}
              onChangeText={(value) => handleChange("email", value)}
            />
            {isEmailValid !== null && (
              <Icon
                name={isEmailValid ? "check" : "times"}
                size={20}
                color={isEmailValid ? "#27AE60" : "#E74C3C"}
                style={styles.inputIcon}
              />
            )}
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="First Name"
              placeholderTextColor="#888888"
              value={formData.first_name}
              onChangeText={(value) => handleChange("first_name", value)}
            />
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="Last Name"
              placeholderTextColor="#888888"
              value={formData.last_name}
              onChangeText={(value) => handleChange("last_name", value)}
            />
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="Password"
              placeholderTextColor="#888888"
              secureTextEntry={!showPassword1}
              value={formData.password1}
              onChangeText={(value) => handleChange("password1", value)}
            />
            <TouchableOpacity
              onPress={() => setShowPassword1(!showPassword1)}
              style={styles.inputIcon}
            >
              <Icon
                name={showPassword1 ? "eye-slash" : "eye"}
                size={20}
                color="#888888"
              />
            </TouchableOpacity>
          </View>

          <View style={styles.inputContainer}>
            <TextInput
              style={styles.input}
              placeholder="Confirm Password"
              placeholderTextColor="#888888"
              secureTextEntry={!showPassword2}
              value={formData.password2}
              onChangeText={(value) => handleChange("password2", value)}
            />
            <TouchableOpacity
              onPress={() => setShowPassword2(!showPassword2)}
              style={styles.inputIcon}
            >
              <Icon
                name={showPassword2 ? "eye-slash" : "eye"}
                size={20}
                color="#888888"
              />
            </TouchableOpacity>
          </View>

          {signupError && <Text style={styles.errorText}>{signupError}</Text>}

          <TouchableOpacity style={styles.signupButton} onPress={handleSignup}>
            <Text style={styles.signupButtonText}>CREATE ACCOUNT</Text>
          </TouchableOpacity>

          <TouchableOpacity onPress={() => navigation.navigate("Login")}>
            <Text style={styles.loginLink}>
              Already have an account? Sign In
            </Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#E4F0F6",
  },
  scrollContainer: {
    flexGrow: 1,
    padding: 20,
  },
  logoContainer: {
    alignItems: "center",
    marginTop: 40,
    marginBottom: 30,
  },
  logoText: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#002D62",
    marginTop: 10,
  },
  signupContainer: {
    backgroundColor: "#fff",
    padding: 20,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 3,
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#002D62",
    marginBottom: 20,
    textAlign: "center",
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15,
    backgroundColor: "#FFFFFF",
    borderWidth: 1,
    borderColor: "#CFCFCF",
    borderRadius: 10,
  },
  input: {
    flex: 1,
    height: 50,
    paddingHorizontal: 16,
    fontSize: 16,
    color: "#333",
  },
  inputIcon: {
    padding: 10,
  },
  errorText: {
    color: "#E74C3C",
    fontSize: 14,
    marginBottom: 15,
    textAlign: "center",
  },
  signupButton: {
    width: "100%",
    backgroundColor: "#002D62",
    padding: 15,
    borderRadius: 10,
    alignItems: "center",
    elevation: 3,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
  },
  signupButtonText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
  },
  loginLink: {
    color: "#002D62",
    textAlign: "center",
    marginTop: 20,
    fontSize: 14,
  },
});

export default SignupScreen;
7)import React, { useState, useEffect, useRef, useCallback } from 'react';
import {
  View,
  Text,
  TextInput,
  ScrollView,
  TouchableOpacity,
  StyleSheet,
  Animated,
  Platform,
  KeyboardAvoidingView,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { API_URL } from '../../config'; // Ensure this is properly defined in your config
import { useAuth } from '../../contexts/AuthContext';
import AnimatedBotMessage from '../../components/chatbot/AnimatedBotMessage';
import TypingIndicator from '../../components/chatbot/TypingIndicator';

interface Message {
  id: string;
  sender: string;
  content: string;
  timestamp: string;
  is_chatbot: boolean;
}

export default function ChatbotScreen() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const [conversationId, setConversationId] = useState<number | null>(null);
  const { accessToken } = useAuth();
  const scrollViewRef = useRef<ScrollView | null>(null);
  const typingOpacity = useRef(new Animated.Value(1)).current;
  const pollingRef = useRef<NodeJS.Timeout | null>(null);

  // Initialize chatbot conversation
  const initializeChatbotConversation = useCallback(async () => {
    try {
      const response = await fetch(`${API_URL}/messaging/chatbot/`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) throw new Error('Failed to initialize chatbot conversation');

      const data = await response.json();
      setConversationId(data.id);
      return data.id;
    } catch (error) {
      Alert.alert('Error', 'Could not start chatbot conversation');
      console.error(error);
      return null;
    }
  }, [accessToken]);

  // Fetch messages
  const fetchMessages = useCallback(async () => {
    if (!conversationId) return;

    try {
      const response = await fetch(`${API_URL}/messaging/chatbot/${conversationId}/`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) throw new Error('Failed to fetch messages');

      const data = await response.json();
      // If response contains a "messages" key, process as before.
      if (data.messages) {
        const messagesArray = Array.isArray(data.messages) ? data.messages : [];
        const formattedMessages = messagesArray.map((msg: any) => ({
          id: msg.id.toString(),
          sender: msg.is_chatbot ? 'Samantha' : 'You',
          content: msg.content,
          timestamp: msg.timestamp,
          is_chatbot: msg.is_chatbot,
        }));
        if (
          formattedMessages.length > 0 &&
          formattedMessages[formattedMessages.length - 1].is_chatbot
        ) {
          setIsTyping(false);
        }
        setMessages(formattedMessages);
      } else {
        console.info('No messages key found in response:', data);
        // Instead of clearing messages, simply turn off the typing indicator.
        setIsTyping(false);
      }
    } catch (error) {
      console.error('Error fetching messages:', error);
    }
  }, [conversationId, accessToken]);

  // Send a message
  const sendMessage = useCallback(async () => {
    if (!input.trim() || !conversationId) return;

    try {
      // Use a temporary ID for the optimistic update.
      const tempId = 'temp-' + Date.now().toString();
      const userMessage = {
        id: tempId,
        sender: 'You',
        content: input.trim(),
        timestamp: new Date().toISOString(),
        is_chatbot: false,
      };

      // Optimistically add the user message
      setMessages((prev) => [...prev, userMessage]);
      setInput('');
      setIsTyping(true);

      const response = await fetch(`${API_URL}/messaging/chatbot/${conversationId}/send_message/`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content: input.trim() }),
      });

      if (!response.ok) {
        throw new Error('Failed to send message');
      }

      // Parse the response immediately
      const result = await response.json();
      console.log('Response from chatbot:', result);
      if (result.bot_response && result.user_message) {
        const formattedUser = {
          id: result.user_message.id.toString(),
          sender: 'You',
          content: result.user_message.content,
          timestamp: result.user_message.timestamp,
          is_chatbot: false,
        };
        const formattedBot = {
          id: result.bot_response.id.toString(),
          sender: 'Samantha',
          content: result.bot_response.content,
          timestamp: result.bot_response.timestamp,
          is_chatbot: true,
        };

        // Replace the optimistic message with the server response and append the bot message.
        setMessages((prev) => {
          const updated = prev.map((msg) => (msg.id === tempId ? formattedUser : msg));
          return [...updated, formattedBot];
        });
        setIsTyping(false);
      } else {
        // Fallback: poll for messages
        setTimeout(() => fetchMessages(), 1500);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      Alert.alert('Error', 'Message could not be sent');
    }
  }, [input, conversationId, accessToken, fetchMessages]);

  // Typing animation
  useEffect(() => {
    if (isTyping) {
      const animation = Animated.loop(
        Animated.sequence([
          Animated.timing(typingOpacity, { toValue: 0.3, duration: 500, useNativeDriver: Platform.OS !== 'web' }),
          Animated.timing(typingOpacity, { toValue: 1, duration: 500, useNativeDriver: Platform.OS !== 'web' }),
        ])
      );
      animation.start();
      return () => animation.stop();
    }
  }, [isTyping, typingOpacity]);

  // Initialize conversation
  useEffect(() => {
    initializeChatbotConversation();
  }, [initializeChatbotConversation]);

  // Setup polling
  useEffect(() => {
    if (conversationId) {
      fetchMessages();
      pollingRef.current = setInterval(fetchMessages, 3000);
    }
    return () => {
      if (pollingRef.current) {
        clearInterval(pollingRef.current);
      }
    };
  }, [conversationId, fetchMessages]);

  return (
    <SafeAreaView style={styles.container}>
      <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={styles.keyboardAvoidingView}>
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Chat with Samantha </Text>
        </View>

        <ScrollView ref={scrollViewRef} contentContainerStyle={styles.messagesContainer}>
          {messages.map((msg, index) => (
            <View key={index} style={[styles.messageRow, msg.is_chatbot ? styles.botMessageRow : styles.userMessageRow]}>
              <View style={[styles.messageBubble, msg.is_chatbot ? styles.botBubble : styles.userBubble]}>
                {msg.is_chatbot ? (
                  <AnimatedBotMessage text={msg.content} />
                ) : (
                  <Text style={msg.is_chatbot ? styles.botText : styles.userText}>{msg.content}</Text>
                )}
              </View>
            </View>
          ))}
          {isTyping && <TypingIndicator visible={isTyping} />}
        </ScrollView>

        <View style={styles.inputContainer}>
          <TextInput style={styles.input} value={input} onChangeText={setInput} placeholder="Type a message..." />
          <TouchableOpacity style={styles.sendButton} onPress={sendMessage} disabled={!input.trim()}>
            <Text style={styles.sendButtonText}>Send</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  keyboardAvoidingView: { flex: 1 },
  header: { padding: 16, backgroundColor: '#FFFFFF', borderBottomWidth: 1, borderBottomColor: '#E5E5E5' },
  headerTitle: { fontSize: 20, fontWeight: 'bold', textAlign: 'center', color: '#002D62' },
  messagesContainer: { paddingHorizontal: 12, paddingBottom: 20 },
  messageRow: { flexDirection: 'row', marginVertical: 5 },
  botMessageRow: { justifyContent: 'flex-start' },
  userMessageRow: { justifyContent: 'flex-end' },
  messageBubble: { maxWidth: '75%', padding: 12, borderRadius: 16 },
  botBubble: { backgroundColor: '#FFF', borderWidth: 1, borderColor: '#E5E5E5' },
  userBubble: { backgroundColor: '#002D62' },
  botText: { color: '#333' },
  userText: { color: '#FFF' },
  typingIndicator: { padding: 8, marginLeft: 10 },
  typingText: { color: '#666', fontStyle: 'italic' },
  inputContainer: { flexDirection: 'row', padding: 12, backgroundColor: '#FFF', borderTopWidth: 1, borderTopColor: '#E5E5E5' },
  input: { flex: 1, marginRight: 12, padding: 10, backgroundColor: '#F5F5F5', borderRadius: 24, fontSize: 16 },
  sendButton: { paddingVertical: 10, paddingHorizontal: 20, borderRadius: 20, backgroundColor: '#002D62' },
  sendButtonText: { color: '#FFF', fontWeight: 'bold' },
});
8)//screens/ChatScreen/hooks/useChatMessages.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useAuth } from '../../../contexts/AuthContext';
import { Message, Conversation } from '../../../types/chat';
import { API_BASE_URL } from '../../../config';
import { getAuthToken } from "../../../utils/auth";
import { connectWebSocket } from '../../../services/websocket';

// Remove the useDebounce import since we don't need it anymore

interface EditMessageParams {
  message: Message;
  onSave: (newContent: string) => Promise<void>;
}

interface AppRoutes {
  EditMessage: EditMessageParams;
}

// Dynamic endpoint helper:
const getEndpoint = (conversationType: string): string => {
  switch (conversationType) {
    case 'group':
      return 'groups';
    case 'one_to_one':
      // Updated endpoint based on backend expectation
      return 'one_to_one';
    case 'chatbot':
      return 'chatbot';
    default:
      throw new Error('Invalid conversation type');
  }
};

interface UseChatMessagesProps {
  conversationId: string;
  conversationType: 'one_to_one' | 'group' | 'chatbot';
}

const useChatMessages = ({ conversationId, conversationType }: UseChatMessagesProps) => {
  const { accessToken, user } = useAuth();
  const navigation = useNavigation<NavigationProp<AppRoutes>>();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [conversation, setConversation] = useState<Conversation | null>(null);
  // Remove isTyping state
  // For pagination (cursor-based)
  const [lastCursor, setLastCursor] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const ws = useRef<WebSocket | null>(null);

  const endpoint = getEndpoint(conversationType);

  const fetchMessages = async (conversationId: string, accessToken: string): Promise<{ messages: Message[]; conversation: Conversation; cursor?: string }> => {
    // Removed chatbot branch; using default endpoint for all conversation types
    const url = `${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/?conversation=${conversationId}&page_size=20`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      }
    });
    if (!response.ok) {
      throw new Error(`Failed to load messages: ${response.status}`);
    }
    const data = await response.json();
    
    let nextCursor = null;
    if (data.next) {
      try {
        const nextUrl = new URL(data.next);
        nextCursor = nextUrl.searchParams.get('cursor');
      } catch (e) {
        nextCursor = data.next;
      }
    }
    
    const messagesList = data.results || data.messages || [];
    
    return { 
      messages: messagesList.reverse(), 
      conversation: data.conversation || { id: conversationId }, 
      cursor: nextCursor 
    };
  };

  const sendMessage = async (conversationId: string, content: string, accessToken: string): Promise<Message> => {
    const payload = {
      conversation: parseInt(conversationId, 10),
      content,
      message_type: 'text'
    };
    
    const url = `${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to send message: ${errorText}`);
    }
    
    const message = await response.json();
    return message;
  };

  const deleteMessageAPI = async (messageId: string, accessToken: string): Promise<void> => {
    const response = await fetch(`${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/${messageId}/`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    if (!response.ok) {
      throw new Error(`Failed to delete message: ${response.status}`);
    }
  };

  const editMessageAPI = async (messageId: string, newContent: string, conversationId: string, accessToken: string): Promise<void> => {
    // Match API payload structure based on docs
    const payload = {
      conversation: parseInt(conversationId, 10),
      content: newContent,
      message_type: 'text'
    };
    
    const response = await fetch(`${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/${messageId}/`, {
      method: 'PATCH', // Using PATCH instead of PUT for partial updates
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to edit message: ${errorText}`);
    }
  };

  // Load messages on mount
  useEffect(() => {
    if (accessToken && conversationId) {
      loadMessages();
    }
  }, [conversationId, accessToken]);

  const loadMessages = useCallback(async () => {
    if (!accessToken) return;
    try {
      setLoading(true);
      setError(null);
      const { messages: fetchedMessages, conversation: conv, cursor } = await fetchMessages(conversationId, accessToken);
      setMessages(fetchedMessages);
      setConversation(conv);
      setHasMore(!!cursor);
      setLastCursor(cursor || null);
    } catch (err: any) {
      console.error('Error loading messages:', err);
      setError(err.message || 'Failed to load messages');
    } finally {
      setLoading(false);
    }
  }, [conversationId, accessToken, endpoint]);

  // Remove the handleTyping function entirely

  // Cursor-based pagination for loading more messages
  const loadMoreMessages = async () => {
    if (!accessToken || !lastCursor || !hasMore || loading) return;
    
    try {
      setLoading(true);
      // Removed chatbot branch; always use the default URL.
      let url = `${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/?conversation=${conversationId}&cursor=${lastCursor}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to load more messages: ${response.status}`);
      }
      
      const data = await response.json();
      const messagesList = data.results || data.messages || [];
      
      setMessages(prev => [...prev, ...messagesList.reverse()]);
      
      if (data.cursor) {
        setLastCursor(data.cursor);
        setHasMore(true);
      } else if (data.next) {
        try {
          const nextUrl = new URL(data.next);
          const nextCursor = nextUrl.searchParams.get('cursor');
          setLastCursor(nextCursor);
          setHasMore(!!nextCursor);
        } catch (e) {
          setLastCursor(data.next);
          setHasMore(!!data.next);
        }
      } else {
        setLastCursor(null);
        setHasMore(false);
      }
    } catch (error: any) {
      console.error('Pagination error:', error);
      setError(error.message || 'Failed to load more messages');
    } finally {
      setLoading(false);
    }
  };

  const handleSend = useCallback(async () => {
    if (!inputText.trim() || !accessToken) return;
    
    const tempId = Date.now().toString();
    const newMessage: Message = {
      id: tempId,
      content: inputText,
      sender: {
        id: user?.id || 'user',
        name: user?.username || 'User', // Changed from user?.name to user?.username
      },
      timestamp: new Date().toISOString(),
      status: 'sending',
      reactions: {}
    };

    // Optimistic update
    setMessages(prev => [newMessage, ...prev]);
    setInputText('');

    try {
      const sentMessage = await sendMessage(conversationId, inputText, accessToken);
      // Update with server response
      setMessages(prev => prev.map(msg => 
        msg.id === tempId ? { ...sentMessage, status: 'sent' } : msg
      ));
    } catch (err: any) {
      console.error('Send message error:', err);
      setError(err.message || 'Failed to send message');
      // Mark as failed for retry
      setMessages(prev => prev.map(msg => 
        msg.id === tempId ? { ...msg, status: 'failed' } : msg
      ));
    }
  }, [conversationId, inputText, accessToken, user, endpoint]);

  const handleNewMessage = useCallback((newMessage: Message) => {
    // For an inverted list, you may prepend or append.
    setMessages(prev => [newMessage, ...prev]);
  }, []);

  useEffect(() => {
    if (!conversationId) return;

    const token = getAuthToken();
    if (!token) {
      console.error('No token available for WebSocket');
      return;
    }

    // Simplify this by removing typing-related functionality
    ws.current = connectWebSocket(
      conversationId,
      token,
      handleNewMessage
      // Remove typing callback parameter
    );

    return () => {
      if (ws.current) ws.current.close(1000, 'Component unmounted');
    };
  }, [conversationId, handleNewMessage]);

  return {
    messages,
    setMessages, // IMPORTANT: Expose this so ChatScreen can update messages directly
    loading,
    error,
    inputText,
    setInputText,
    handleSend,
    loadMessages,
    loadMoreMessages,
    conversation,
    hasMore,
    // Remove isTyping, setIsTyping, and handleTyping from the return object
    deleteMessage: async (messageId: string) => {
      try {
        await deleteMessageAPI(messageId, accessToken || '');
        setMessages(prev => prev.filter(msg => msg.id !== messageId));
      } catch (err: any) {
        console.error('Delete message error:', err);
        setError(err.message || 'Failed to delete message');
      }
    },
    editMessage: async (messageId: string, newContent: string) => {
      try {
        await editMessageAPI(messageId, newContent, conversationId, accessToken || '');
        setMessages(prev => prev.map(msg => 
          msg.id === messageId ? { ...msg, content: newContent, is_edited: true } : msg
        ));
      } catch (err: any) {
        console.error('Edit message error:', err);
        setError(err.message || 'Failed to edit message');
      }
    }
  };
};

export default useChatMessages;

9)// hooks/useDebounce.ts
import { useEffect, useState } from 'react';

/**
 * Custom hook that debounces a value
 * @param value The value to debounce
 * @param delay Delay in milliseconds (default: 500ms)
 * @returns The debounced value
 */
function useDebounce<T>(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    // Set up the debounce timer
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Clean up the timer on unmount or when value/delay changes
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
110)//screens/ChatScreen/hooks/useMessageActions.ts
import { useState, useCallback } from 'react';
import { useAuth } from '../../../contexts/AuthContext';
import { API_BASE_URL } from '../../../config';
import { Message } from '../../../types/chat';

// Define the conversation types
type ConversationType = 'one_to_one' | 'group' | 'chatbot';

interface UseMessageActionsProps {
  conversationId: string;
  conversationType: ConversationType;
}

const useMessageActions = ({ conversationId, conversationType }: UseMessageActionsProps) => {
  // Extract the current user as well as the access token.
  const { accessToken, user } = useAuth();
  const [selectedMessage, setSelectedMessage] = useState<Message | null>(null);
  const [showActions, setShowActions] = useState(false);
  const [showReactions, setShowReactions] = useState(false);

  const addReactionAPI = async (
    messageId: string,
    reaction: string,
    conversationId: string,
    conversationType: ConversationType,
    accessToken: string,
    userId: string
  ): Promise<void> => {
    if (conversationType === 'chatbot') {
      console.warn('Reactions not supported for chatbot messages');
      return;
    }

    // Get the right endpoint based on conversation type
    const endpoint = conversationType === 'group' ? 'groups' : 'one_to_one';
    
    // The API structure differs between endpoints
    let requestBody = {};
    
    if (conversationType === 'group') {
      requestBody = {
        conversation: parseInt(conversationId, 10),
        reactions: { [reaction]: [userId] }
      };
    } else {
      // For one-to-one messages
      requestBody = {
        [reaction]: userId
      };
    }
    
    const response = await fetch(`${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/${messageId}/reactions/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`,
      },
      body: JSON.stringify(requestBody),
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to add reaction: ${errorText}`);
    }
  };

  const handleMessagePress = (message: Message): void => {
    setSelectedMessage(message);
    setShowActions(true);
  };

  const handleReactionSelect = useCallback(async (reaction: string): Promise<void> => {
    if (!selectedMessage || !accessToken || !user) return;
    try {
      await addReactionAPI(
        selectedMessage.id, 
        reaction, 
        conversationId, 
        conversationType,
        accessToken, 
        user.id
      );
      console.log(`Added reaction ${reaction} to message ${selectedMessage.id}`);
    } catch (error) {
      console.error('Failed to add reaction:', error);
    }
    setShowReactions(false);
  }, [selectedMessage, accessToken, user, conversationId, conversationType]);

  const removeReaction = async (messageId: string, reaction: string): Promise<void> => {
    if (!accessToken || !user) return;
    
    if (conversationType === 'chatbot') {
      console.warn('Reactions not supported for chatbot messages');
      return;
    }
    
    try {
      // Get the right endpoint based on conversation type
      const endpoint = conversationType === 'group' ? 'groups' : 'one_to_one';
      
      // Updated URL: no reaction query parameter since the API doesn't require it.
      const url = `${API_BASE_URL}/api/v1/messaging/${endpoint}/messages/${messageId}/reactions/`;
      
      const options: RequestInit = {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
        }
      };
      
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to remove reaction: ${errorText}`);
      }
    } catch (error) {
      console.error('Failed to remove reaction:', error);
    }
  };

  return {
    selectedMessage,
    showActions,
    showReactions,
    handleMessagePress,
    handleReactionSelect,
    removeReaction,
    setShowActions,
    setShowReactions,
  };
};

export default useMessageActions;
11)//screens/ChatScreen/services/api.ts
import axios from 'axios';
import { API_URL } from '../../../config';
import { Message, ApiErrorResponse, PaginatedMessagesResponse } from '../../../types/chat';

export const fetchInitialMessages = async (
  conversationId: string,
  conversationType: 'one_to_one' | 'group'
): Promise<{ messages: Message[], hasMore: boolean }> => {
  if (!conversationId) {
    console.error('Invalid conversation ID');
    return { messages: [], hasMore: false };
  }
  
  // Use proper pluralization for group conversations: "groups" vs "one_to_one"
  const conversationEndpoint = conversationType === 'group' ? 'groups' : 'one_to_one';
  const endpoint = `${API_URL}/messaging/${conversationEndpoint}/messages/`;

  try {
    const response = await axios.get<PaginatedMessagesResponse>(endpoint, {
      params: { conversation: conversationId }
    });
    
    return { 
      messages: response.data.results, 
      hasMore: response.data.has_more || false
    };
  } catch (error) {
    const axiosError = error as any;
    
    if (axiosError.response) {
      const errorData = axiosError.response.data;
      console.error('Error fetching messages:', errorData.message || 'Unknown error');
      
      if (errorData.errors) {
        Object.entries(errorData.errors).forEach(([field, errors]) => {
          const errorMessages = Array.isArray(errors) ? errors : [];
          console.error(`${field}: ${errorMessages.join(', ')}`);
        });
      }
    } else if (axiosError.request) {
      console.error('Error fetching messages: No response received from server');
    } else {
      console.error('Error fetching messages:', axiosError.message);
    }
    
    return { messages: [], hasMore: false };
  }
};

export const fetchMoreMessages = async (
  conversationId: string,
  conversationType: 'one_to_one' | 'group',
  beforeId?: string
): Promise<{ messages: Message[], hasMore: boolean }> => {
  if (!conversationId) {
    console.error('Invalid conversation ID');
    return { messages: [], hasMore: false };
  }
  
  const conversationEndpoint = conversationType === 'group' ? 'groups' : 'one_to_one';
  const endpoint = `${API_URL}/messaging/${conversationEndpoint}/messages/`;

  try {
    // Include both conversation ID and cursor (beforeId) in params
    const params: Record<string, string> = { conversation: conversationId };
    if (beforeId) {
      params.cursor = beforeId;
    }
    
    const response = await axios.get<PaginatedMessagesResponse>(endpoint, { params });
    
    return { 
      messages: response.data.results, 
      hasMore: response.data.has_more || false
    };
  } catch (error) {
    const axiosError = error as any;
    console.error('Error fetching more messages:', 
      axiosError.response?.data?.message || axiosError.message || 'Unknown error');
    return { messages: [], hasMore: false };
  }
};

12)//screens/ChatScreen/ChatScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { View, StyleSheet, FlatList, KeyboardAvoidingView, Platform, Alert, ActivityIndicator } from 'react-native';
import { RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { useNetInfo } from '@react-native-community/netinfo';
import { MessagingStackParamList } from '../../navigation/MessagingNavigator';
import useChatMessages from './hooks/useChatMessages';
import useMessageActions from './hooks/useMessageActions';
import MessageBubble from './components/MessageBubble';
import MessageInput from './components/MessageInput';
import ChatHeader from './components/ChatHeader';
import LoadingIndicator from '../../components/ui/LoadingIndicator';
import ErrorMessage from '../../components/ui/ErrorMessage';
import { Message } from '../../types/chat';
import { useAuth } from '../../contexts/AuthContext';
import { useWebSocket } from '../../services/websocket';

type ChatRouteProp = RouteProp<MessagingStackParamList, 'Chat'>;
type ChatNavigationProp = StackNavigationProp<MessagingStackParamList, 'Chat'>;

interface ChatScreenProps {
  route: ChatRouteProp;
  navigation: ChatNavigationProp;
}

const ChatScreen: React.FC<ChatScreenProps> = ({ route, navigation }) => {
  const { conversationId, conversationType, title } = route.params;
  const { user } = useAuth();
  const netInfo = useNetInfo();
  const [isRetrying, setIsRetrying] = useState(false);
  const [editingMessage, setEditingMessage] = useState<Message | null>(null);
  const [isLoadingMore, setIsLoadingMore] = useState(false);

  const {
    messages,
    loading,
    error,
    inputText,
    handleSend,
    setInputText,
    loadMessages,
    conversation,
    hasMore: hasMoreMessages,
    deleteMessage: deleteMessageApi,
    editMessage: editMessageApi,
    setMessages,
  } = useChatMessages({
    conversationId: String(conversationId),
    conversationType,
  });

  const loadMoreMessagesFromApi = useCallback(async () => {
    if (!hasMoreMessages || isLoadingMore) return;
    
    try {
      setIsLoadingMore(true);
      await loadMessages();
    } catch (error) {
      console.error('Failed to fetch more messages:', error);
    } finally {
      setIsLoadingMore(false);
    }
  }, [hasMoreMessages, isLoadingMore, loadMessages]);

  const handleWebSocketMessage = useCallback(
    (data: any) => {
      console.log("[WS] Raw data received:", data);
      
      if (
        (data.type && data.type.includes('message')) ||
        data.message || 
        data.content || data.id
      ) {
        const newMsg = data.message || data;
        
        console.log("[WS] Processing potential new message:", newMsg);
        
        // ONLY update messages directly, don't call loadMessages()
        if (newMsg && newMsg.id && typeof setMessages === 'function') {
          // Check if we already have this message
          const existingMessage = messages.find(m => m.id === newMsg.id);
          if (!existingMessage) {
            console.log("[WS] Adding new message to state:", newMsg);
            setMessages(prev => [newMsg, ...prev]);
          }
        }
        // Removed the loadMessages() fallback to prevent rate limiting
      } else if (data.type === 'connection_established') {
        console.log('[WS] WebSocket connection established');
      } else {
        console.warn("[WS] Unhandled message type:", data.type, data);
      }
    },
    [conversationId, messages, setMessages]
  );

  useWebSocket(conversationId, handleWebSocketMessage);

  useEffect(() => {
    if (!conversationId || !conversationType || !title) {
      console.error('Invalid navigation parameters:', route.params);
      navigation.goBack();
    }
  }, [conversationId, conversationType, title, navigation]);

  useEffect(() => {
    console.log('ChatScreen opened with:', conversationId, conversationType, title);
  }, []);

  const { handleReactionSelect, removeReaction } = useMessageActions({
    conversationId: String(conversationId),
    conversationType,
  });

  const handleReaction = useCallback(
    async (messageId: string, reaction: string) => {
      try {
        console.log(`Adding reaction ${reaction} to message ${messageId}`);
        await handleReactionSelect(reaction);
      } catch (error) {
        console.error('Failed to add reaction:', error);
        Alert.alert('Error', 'Failed to add reaction');
      }
    },
    [handleReactionSelect]
  );

  const handleDeleteMessage = useCallback(
    (messageId: string) => {
      Alert.alert('Delete Message', 'Are you sure you want to delete this message?', [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await deleteMessageApi(messageId);
            } catch (error) {
              console.error('Failed to delete message:', error);
              Alert.alert('Error', 'Failed to delete message');
            }
          },
        },
      ]);
    },
    [deleteMessageApi]
  );

  const handleEditMessage = useCallback(
    (messageId: string) => {
      const message = messages.find((msg) => msg.id === messageId);
      if (message) {
        setEditingMessage(message);
        setInputText(message.content);
      }
    },
    [messages, setInputText]
  );

  const handleSaveEdit = useCallback(async () => {
    if (!editingMessage) return;
    
    try {
      await editMessageApi(editingMessage.id, inputText);
      setEditingMessage(null);
      setInputText('');
    } catch (error) {
      console.error('Failed to update message:', error);
      Alert.alert('Error', 'Failed to update message');
    }
  }, [editingMessage, inputText, editMessageApi]);

  const handleCancelEdit = useCallback(() => {
    setEditingMessage(null);
    setInputText('');
  }, []);

  useEffect(() => {
    if (error && !isRetrying) {
      Alert.alert('Error', 'Failed to load messages. Would you like to retry?', [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Retry',
          onPress: async () => {
            setIsRetrying(true);
            try {
              await loadMessages();
            } finally {
              setIsRetrying(false);
            }
          },
        },
      ]);
    }
  }, [error, isRetrying, loadMessages]);

  useEffect(() => {
    if (!netInfo.isConnected && netInfo.isInternetReachable === false) {
      Alert.alert(
        'No Connection',
        'You are currently offline. Messages will be sent when you reconnect.'
      );
    }
  }, [netInfo.isConnected, netInfo.isInternetReachable]);

  useEffect(() => {
    if (!netInfo.isConnected) return;
    
    const interval = setInterval(() => {
      loadMessages();
    }, 30000); // Change from 10000 (10s) to 30000 (30s)
    
    return () => clearInterval(interval);
  }, [loadMessages, netInfo.isConnected]);

  const renderFooter = () => {
    if ((loading && hasMoreMessages) || isRetrying || isLoadingMore) {
      return <ActivityIndicator style={styles.loader} color="#007AFF" size="small" />;
    }
    return null;
  };

  if (loading && !messages.length) {
    return <LoadingIndicator />;
  }
  
  return (
    <View style={styles.container}>
      <ChatHeader conversation={conversation} />
      
      {error && !loading && (
        <ErrorMessage message="Couldn't load all messages" onRetry={loadMessages} />
      )}
      
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.content}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 88 : 0}
      >
        <FlatList
          data={messages}
          renderItem={({ item }) => (
            <MessageBubble 
              message={item} 
              onReaction={handleReaction}
              onRemoveReaction={removeReaction}
              onEdit={handleEditMessage}
              onDelete={handleDeleteMessage}
            />
          )}
          keyExtractor={(item) => item.id}
          inverted
          onEndReached={hasMoreMessages ? loadMoreMessagesFromApi : null}
          onEndReachedThreshold={0.5}
          ListFooterComponent={renderFooter}
          contentContainerStyle={styles.listContent}
        />
        
        <MessageInput
          value={inputText}
          onChangeText={setInputText}
          onSend={editingMessage ? handleSaveEdit : handleSend}
          editMessage={editingMessage}
          onEditCancel={handleCancelEdit}
        />
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F0F4F8',
  },
  content: {
    flex: 1,
  },
  listContent: {
    paddingTop: 16,
    paddingHorizontal: 16,
    paddingBottom: 8,
  },
  loader: {
    marginVertical: 20,
  },
});

export default ChatScreen;
13)import { useEffect, useRef, useCallback } from 'react';
import { WS_BASE_URL } from '../config';
import { getAuthToken } from '../utils/auth';

interface WebSocketMessage {
  type: string;
  data?: any;
}

interface WebSocketHook {
  sendMessage: (message: WebSocketMessage) => void;
  connectionStatus: 'connecting' | 'connected' | 'disconnected';
}

// This is your dedicated connectWebSocket utility.
export const connectWebSocket = (
  conversationId: string,
  token: string,
  onMessageReceived: (message: any) => void,
  onTypingIndicator?: (data: any) => void,
  onReadReceipt?: (data: any) => void
): WebSocket => {
  const socket = new WebSocket(`${WS_BASE_URL}/ws/messaging/${conversationId}/?token=${token}`);

  socket.onopen = () => {
    console.log('WebSocket connection established (utility)');
    // Optionally send join/presence message
    socket.send(JSON.stringify({ type: 'join', data: { conversation_id: conversationId } }));
  };

  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log('[WS Utility] Raw message:', data);
      if (data.type === 'conversation_message' || data.type === 'new_message') {
        console.log('[WS Utility] New message event received.');
        onMessageReceived(data.message || data.data);
      } else if (data.type === 'typing_indicator' && onTypingIndicator) {
        onTypingIndicator(data);
      } else if (data.type === 'read_receipt' && onReadReceipt) {
        onReadReceipt(data);
      } else if (data.type === 'connection_established') {
        console.log('WebSocket connection confirmed (connection_established)');
      } else {
        console.warn('Unhandled message type in utility:', data.type, data);
      }
    } catch (error) {
      console.error('Error processing websocket message in utility:', error);
    }
  };

  socket.onerror = (error) => {
    console.error('WebSocket error (utility):', error);
  };

  socket.onclose = (event) => {
    console.log('WebSocket closed (utility). Code:', event.code);
  };

  return socket;
};

// The hook now uses connectWebSocket and does not override its events.
export const useWebSocket = (
  conversationId: string,
  onMessageReceived: (data: any) => void
): WebSocketHook => {
  const ws = useRef<WebSocket | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;
  const reconnectDelay = 3000; 
  const onMessageReceivedRef = useRef(onMessageReceived);
  const connectionStatusRef = useRef<'connecting' | 'connected' | 'disconnected'>('disconnected');

  // Update the message callback ref on change.
  useEffect(() => {
    onMessageReceivedRef.current = onMessageReceived;
  }, [onMessageReceived]);

  const connect = useCallback(() => {
    if (!conversationId) {
      console.warn('Missing conversation ID');
      return;
    }

    const token = getAuthToken();
    if (!token) {
      console.error('No authentication token available');
      return;
    }

    connectionStatusRef.current = 'connecting';

    // Call our utility. Note: Provide a dummy for onTypingIndicator if needed.
    ws.current = connectWebSocket(
      conversationId,
      token,
      (msg) => {
        console.log('[WS Hook] onMessageReceived invoked with:', msg);
        onMessageReceivedRef.current(msg);
      },
      (data) => {
        console.log('[WS Hook] Typing indicator:', data);
      },
      (data) => {
        console.log('[WS Hook] Read receipt:', data);
      }
    );

    ws.current.onclose = (event) => {
      connectionStatusRef.current = 'disconnected';
      if (event.code !== 1000) {
        console.warn(`WebSocket closed unexpectedly. Code: ${event.code}`);
        if (reconnectAttempts.current < maxReconnectAttempts) {
          reconnectAttempts.current += 1;
          console.log(`Reconnecting... Attempt ${reconnectAttempts.current}`);
          setTimeout(connect, reconnectDelay);
        } else {
          console.error('Max reconnection attempts reached');
        }
      }
    };

    ws.current.onerror = (error) => {
      console.error('WebSocket error (hook):', error);
    };

    ws.current.onopen = () => {
      console.log(`[WS Hook] Connected to conversation ${conversationId}`);
      connectionStatusRef.current = 'connected';
      reconnectAttempts.current = 0;
    };
  }, [conversationId]);

  // Connect on mount and when conversationId changes.
  useEffect(() => {
    connect();
    return () => {
      if (ws.current) {
        console.log('[WS Hook] Closing WebSocket on component unmount');
        ws.current.close(1000, 'Component unmounted');
        ws.current = null;
      }
    };
  }, [connect]);

  const sendMessage = useCallback((message: WebSocketMessage) => {
    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify(message));
    } else {
      console.error('WebSocket not connected');
    }
  }, []);

  // Heartbeat to keep the connection alive
  useEffect(() => {
    const heartbeatInterval = setInterval(() => {
      if (ws.current?.readyState === WebSocket.OPEN) {
        sendMessage({ type: 'heartbeat' });
      }
    }, 30000); // every 30 seconds
    return () => clearInterval(heartbeatInterval);
  }, [sendMessage]);

  return {
    sendMessage,
    connectionStatus: connectionStatusRef.current,
  };
};
14)//types/chat.ts
export interface Participant {
  id: string;
  name: string;
  avatar?: string;
}

export interface Message {
  id: string;
  content: string;
  sender: {
    id: string;
    name: string;
  };
  timestamp: string;
  status: 'sending' | 'sent' | 'failed' | 'read';
  reactions: {
    [key: string]: string[];
  };
  // Make these optional if they might not be present
  deleted?: boolean;
  edit_history?: {
    id: string;
    content: string;
    timestamp: string;
  }[];
}

export interface MessageProps {
  id: string;
  content: string;
  sender: {
    id: string;
    name: string;
  };
  timestamp: string;
  edited?: boolean;
  edited_at?: string;
  reactions?: Record<string, string[]>;
  read_by?: string[];
  message_type?: 'text' | 'system';
  status?: 'sent' | 'delivered' | 'read' | 'failed';
}

export interface Conversation {
  id: string;
  name?: string;
  title?: string; // For displaying conversation title
  // API returns snake_case fields
  last_message?: string;     // Matches Django's field name for last message
  unread_count?: number;     // Matches Django's field name for unread count
  // Optional camelCase aliases for internal usage
  lastMessage?: string;
  unreadCount?: number;
  participants?: Participant[];
  otherParticipant?: Participant; // For one-to-one chats
  timestamp?: string;
  conversation_type: 'direct' | 'group' | 'one_to_one' | 'chatbot';
}

export interface RouteProps {
  params: {
    conversationId: string;
  };
}

export interface ConversationSummary {
  id: string;
  title: string;
  last_message?: string;
  timestamp?: string;
  unread_count: number;
  participants: Participant[];
  avatar?: string; // For group chats or single user avatar
}

// Helper types for API responses
export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    current_page: number;
    last_page: number;
    per_page: number;
    total: number;
  };
}

export interface ApiErrorResponse {
  message: string;
  errors?: Record<string, string[]>;
  status_code?: number;
}

// New interfaces for message pagination
export interface PaginatedMessagesResponse {
  results: Message[];
  has_more: boolean;
  next_cursor?: string;
  count?: number;
}
15)//utils/helpers.ts
export const formatTime = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  
  if (date.toDateString() === now.toDateString()) {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  if (date.getFullYear() === now.getFullYear()) {
    return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
  }
  
  return date.toLocaleDateString([], { year: 'numeric', month: 'short', day: 'numeric' });
};

export const getInitials = (name: string): string => {
  if (!name) return '';
  
  return name.split(' ')
    .map(part => part[0])
    .join('')
    .toUpperCase();
};

// Add a new utility function for handling message timestamp display with relative time
export const getRelativeTime = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return 'just now';
  }
  
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes}m ago`;
  }
  
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours}h ago`;
  }
  
  return formatTime(dateString);
};
14)export const retryFetch = async (
    url: string,
    options: RequestInit = {},
    retries: number = 3
  ): Promise<Response> => {
    try {
      const response = await fetch(url, options);
      if (!response.ok && retries > 0) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return retryFetch(url, options, retries - 1);
      }
      return response;
    } catch (error) {
      if (retries > 0) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return retryFetch(url, options, retries - 1);
      }
      throw error;
    }
  };
15)//config.ts
export const API_BASE_URL = __DEV__ 
  ? 'http://127.0.0.1:8000' 
  : 'https://api.mindcareai.com';

export const WS_BASE_URL = API_BASE_URL.replace(
  'http',
  __DEV__ ? 'ws' : 'wss'
);

export const API_URL = `${API_BASE_URL}/api/v1`;

export const SOCIAL_LOGIN_URLS = {
  google: `${API_BASE_URL}/api/v1/auth/login/google/`,
  github: `${API_BASE_URL}/api/v1/auth/login/github/`,
};

export const GOOGLE_CLIENT_ID = '826529019009-12eb7c55fhp7altmd1jnhgel7e92bg39.apps.googleusercontent.com';
export const GITHUB_CLIENT_ID = 'Ov23libU65qS0FNZsNvh';

export const OAUTH_CONFIG = {
  redirectUri: 'com.mindcareai.app:/oauth2redirect',  // Updated redirect URI
  scopes: ['openid', 'email', 'profile'],
  responseType: 'code',
  accessType: 'offline',
  prompt: 'consent',
  githubAuth: {
    scope: 'user:email',
    allowSignup: true
  }
};

