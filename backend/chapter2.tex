% New Chapter 2 (Methodology and Development Framework)
\chapter{Methodology and Development Framework}

\section{Scrum Methodology}

\subsection{Scrum Framework}

Scrum is an Agile framework for managing complex projects through iterative, time-boxed sprints, promoting transparency, inspection, and adaptation.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth]{images/chapter2/scrum2.jpg}
\caption{Scrum Framework}
\label{fig:scrum-framework}
\end{figure}

\subsection{Scrum Roles}

Every member of the Scrum Team works at the same level, without hierarchical relationships, collaborating toward the product goal.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth]{images/chapter2/scrum roles.png}
\caption{Scrum Roles at Mobelite}
\label{fig:scrum-roles}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{|p{0.2\textwidth}|p{0.7\textwidth}|}
\hline
\textbf{Role} & \textbf{Description} \\
\hline
Product Owner & Maximizes product value and manages the Product Backlog. \\
\hline
Scrum Master & Servant-leader who ensures Scrum events occur and the team removes impediments. \\
\hline
Development Team & Cross-functional professionals who build the product increment and uphold quality. \\
\hline
\end{tabular}
\caption{Scrum Team Roles}
\label{tab:scrum-team}
\end{table}

\subsection{Scrum Events}

\begin{table}[H]
\centering
\begin{tabular}{|p{0.2\textwidth}|p{0.7\textwidth}|}
\hline
\textbf{Event} & \textbf{Description} \\
\hline
Sprint & A time-boxed cycle (2â€“4 weeks) producing a potentially shippable increment. \\
\hline
Sprint Planning & Defines the Sprint Backlog and plan (max. 8 h for a 1-month Sprint). \\
\hline
Daily Scrum & 15-minute meeting to inspect progress toward the Sprint Goal. \\
\hline
Sprint Review & Demonstration of the increment and feedback with stakeholders. \\
\hline
Sprint Retrospective & Reflects on the past Sprint to improve processes (max. 3 h for a 1-month Sprint). \\
\hline
\end{tabular}
\caption{Scrum Events}
\label{tab:scrum-events}
\end{table}

\subsection{Advantages \& Disadvantages}

\paragraph{Advantages}
\begin{itemize}
  \item Rapid adaptation through short cycles.
  \item Enhanced transparency and stakeholder feedback.
  \item Continuous improvement via Retrospectives.
\end{itemize}

\paragraph{Disadvantages}
\begin{itemize}
  \item Requires a self-organizing, experienced team.
  \item Potential for scope creep without strong discipline.
  \item Not ideal for fixed-scope, prescriptive projects.
\end{itemize}

\section{Development Framework}

\paragraph{Frontend}  
This project follows a decoupled architecture where the frontend is developed separately using React Native and React.js, enabling both web and mobile interfaces. The frontend implementation details are covered in a separate chapter.

\paragraph{Backend}  
 
\begin{itemize}
  \item \textbf{Django Framework}: The project utilizes Django, a high-level Python web framework that follows the model-view-template architectural pattern. Django provides a robust foundation with built-in security features, admin interface, and ORM (Object-Relational Mapping) capabilities that simplify database interactions. The modular structure of Django aligns perfectly with the project's need for scalability and maintainability in mental healthcare applications.
  
  \item \textbf{Django REST Framework (DRF)}: Built on top of Django, DRF enables the development of RESTful APIs with sophisticated features such as serialization/deserialization, authentication mechanisms (JWT, OAuth), permissions, viewsets, and automatic documentation through drf-spectacular. These components facilitate seamless communication between frontend and backend while ensuring proper access controls for sensitive mental health data.
  
  \item \textbf{PostgreSQL}: As the project's database management system, PostgreSQL offers advanced data types, robust transaction support, and efficient handling of complex queries. Its JSON field capabilities are particularly valuable for storing flexible metadata related to user preferences, therapy session notes, and AI analysis results. The project leverages PostgreSQL's full-text search capabilities for efficient content retrieval within therapy resources.
  
  \item \textbf{Authentication System}: The project implements a comprehensive authentication system using dj-rest-auth and django-allauth, supporting both traditional email/password authentication and social authentication (e.g., Google OAuth). This system includes custom email verification flows, password reset mechanisms, and role-based access control for different user types (patients, therapists, administrators).
  
  \item \textbf{Channels}: For real-time communication features like notifications and chat functionality, Django Channels extends Django's capabilities to handle WebSockets, enabling bidirectional communication essential for interactive therapeutic sessions. The middleware system ensures proper authentication for WebSocket connections, maintaining security in real-time interactions.
  
  \item \textbf{Celery}: To handle asynchronous tasks such as AI processing and notification delivery, the project employs Celery as a distributed task queue, ensuring responsive user experience even during computationally intensive operations like sentiment analysis and therapeutic content generation. Scheduled tasks automate routine operations like mood analysis and therapeutic reminder delivery.
  
  \item \textbf{Django Filters}: Advanced search and filtering capabilities are implemented using django-filter, enabling users to efficiently find therapists based on specializations, languages, and availability. These filtering capabilities extend to appointment scheduling, therapy resources, and community support content.
  
  \item \textbf{RESTful API Architecture}: The backend follows RESTful design principles, organizing endpoints by resource types (users, appointments, messages, etc.) with appropriate HTTP methods. This architecture provides clear separation of concerns and enables efficient communication between frontend components and backend services while facilitating future mobile application integration.
  
  \item \textbf{JWT Authentication}: The system utilizes JSON Web Tokens for secure API authentication, implementing token refresh mechanisms to maintain session security while providing a seamless user experience. This approach is particularly important for maintaining continuous secure connections during therapy sessions.
  
  \item \textbf{Redis}: Employed as both the Channels layer backend, Celery broker and result store, and cache backend using django-redis. Redis ensures high-performance message brokering, real-time updates, and efficient cache operations for notifications and frequently accessed data.
  
  \item \textbf{Containerization with Docker Compose}: The development and deployment environment is standardized using Docker Compose, orchestrating services such as PostgreSQL, Redis, Celery workers, Channels, and the Django application. A GPU-enabled compose file supports AI workloads requiring GPU acceleration.
  
  \item \textbf{Environment Configuration}: Python-dotenv is used to load environment variables from a ".env" file, enabling secure management of sensitive keys and configuration for local and cloud deployments.
  
  \item \textbf{API Documentation}: drf-spectacular generates OpenAPI schema and Swagger/Redoc documentation automatically, ensuring up-to-date API references and facilitating integration by frontend and third-party clients.
  
  \item \textbf{Two-Factor Authentication}: django-otp provides TOTP based multi-factor authentication support, enhancing security for user accounts requiring higher assurance.
  
  \item \textbf{CORS Handling}: django-cors-headers manages Cross-Origin Resource Sharing policies, allowing the React Native and web clients to communicate securely with the backend across origins.

  \item \textbf{Media Management Module}: A dedicated media handler app manages file uploads using Django's content type framework, validating file size, type, and enforcing scan-on-upload policies to ensure secure media storage.

  \item \textbf{Signal-Driven Architecture}: Django signals decouple event processing across the system (e.g., triggering notifications, journal analysis, AI insight creation), allowing for clean separation of concerns and asynchronous operations.

  \item \textbf{Rate Limiting and Throttling}: DRF's built-in throttle classes and custom rules enforce per-user and per-endpoint rate limits (e.g., messaging and chatbot rates) to protect against abuse and ensure quality of service.

  \item \textbf{Custom Management Commands}: The backend provides custom Django management commands to initialize and index AI resources (e.g., RAG document indexing, AI model setup) as part of deployment and maintenance workflows.

  \item \textbf{Local LLM Integration (Ollama)}: Optionally, the system can connect to a locally running LLM via Ollama, enabling on-premise AI processing without external API dependencies.

  \item \textbf{Appointments Module}: A dedicated Django app managing therapist availability and patient bookings, with serializers, custom permissions, and date/time filtering to facilitate secure session scheduling.

  \item \textbf{Messaging Module}: Comprehensive real-time messaging infrastructure supporting one-to-one and group chats via Django Channels and Redis, with WebSocket consumers, offline message handling, and custom throttling to ensure reliability and scale.

  \item \textbf{Notification Service}: A unified notification framework decoupled via Django signals, delivering in-app and email notifications, caching notification types and counts for performance, and configurable channel preferences per user.

  \item \textbf{Logging and Monitoring}: Centralized logging configured with console and file handlers for core components (Django, Channels, messaging, allauth), facilitating traceability and debugging of system behavior in production and development.

  \item \textbf{API Versioning and Namespacing}: All endpoints are namespaced under a versioned API path (e.g., "/api/v1"), enabling backward-compatible API evolution and clear separation of stable and experimental interfaces.

  \item \textbf{Custom Middleware}: A thread-local request middleware stores the current request context application-wide, enabling utility functions and libraries to access request metadata outside view logic.

  \item \textbf{Permission Framework}: Custom DRF permission classes (e.g., IsSuperUserOrSelf, IsUploaderOrReadOnly) enforce fine-grained, role-based access control on various resources (users, media, sessions, etc.).

  \item \textbf{Generic Relations and Content Types}: The backend leverages Django's content type framework and GenericForeignKey for flexible associations of media files, notifications, and reactions, reducing schema complexity and enabling polymorphic linking of related models.

  \item \textbf{Continuous Integration and Deployment (CI/CD)}: Automated pipelines using GitHub Actions or similar for consistent build, test, and deployment workflows.
  \item \textbf{Testing and Quality Assurance}: Comprehensive test suite with pytest for unit and integration tests, automated coverage reporting, and code formatting/linting enforcement (e.g., black, flake8).
  \item \textbf{Security and Vulnerability Scanning}: Integration of static analysis and dependency scanning tools (e.g., Bandit, Snyk, Dependabot) to identify and remediate security issues early.
  \item \textbf{Backup and Disaster Recovery}: Scheduled database and media backups, retention policies, and automated recovery procedures to ensure data durability and business continuity.
  \item \textbf{Performance Monitoring and Tracing}: Integration with APM and monitoring tools (e.g., Prometheus, Grafana, Jaeger) to collect metrics and distributed traces for proactive optimization.
  \item \textbf{Infrastructure as Code}: Provisioning and management of infrastructure resources using tools like Terraform or Ansible to maintain reproducible, version-controlled environments.
\end{itemize}

\section{Authentication and Security}

\subsection{Multi-Layer Authentication}
The system implements a comprehensive authentication strategy:

\begin{itemize}
  \item \textbf{JWT-Based Authentication}:
    \begin{itemize}
      \item Access and refresh token implementation
      \item Token blacklisting for security
      \item Configurable token lifetime settings
    \end{itemize}
    
  \item \textbf{Social Authentication}:
    \begin{itemize}
      \item Google OAuth2 integration
      \item Custom adapter for profile creation
      \item User type handling (patient/therapist)
    \end{itemize}
    
  \item \textbf{Email Verification}:
    \begin{itemize}
      \item Custom email confirmation flow
      \item Resend verification capability
      \item HMAC-based email verification tokens
    \end{itemize}
\end{itemize}

\subsection{Real-time Communication}
The platform's real-time features are built on Django Channels:

\begin{itemize}
  \item \textbf{WebSocket Infrastructure}:
    \begin{itemize}
      \item Authentication middleware for WebSocket connections
      \item Channel layer backed by Redis
      \item Group-based message routing
    \end{itemize}
    
  \item \textbf{Messaging Features}:
    \begin{itemize}
      \item Real-time chat functionality
      \item Presence detection
      \item Message persistence
    \end{itemize}
    
  \item \textbf{Notification System}:
    \begin{itemize}
      \item Real-time notifications
      \item Event-driven architecture
      \item Custom consumer implementations
    \end{itemize}
\end{itemize}

\subsection{Security Measures}
Comprehensive security implementation includes:

\begin{itemize}
  \item \textbf{Permission Framework}:
    \begin{itemize}
      \item Role-based access control
      \item Object-level permissions
      \item Custom permission classes
    \end{itemize}
    
  \item \textbf{Data Protection}:
    \begin{itemize}
      \item Encrypted storage
      \item Secure file handling
      \item CORS policy management
    \end{itemize}
    
  \item \textbf{Rate Limiting}:
    \begin{itemize}
      \item API throttling
      \item WebSocket connection limits
      \item Custom rate limiters
    \end{itemize}
\end{itemize}

\section{AI Tools and Integration}

The MindCare platform leverages several advanced AI technologies to provide intelligent mental health support:

\begin{itemize}
  \item \textbf{Google's Gemini API}: The system integrates with Google's Gemini API, a powerful large language model that powers the therapeutic chatbot functionality. This API enables natural language understanding and generation, allowing the system to engage in human-like therapeutic conversations while maintaining appropriate ethical boundaries and safety measures. The implementation includes specialized safety filters for mental health contexts and robust error handling to ensure reliable service delivery.
  
  \item \textbf{Retrieval-Augmented Generation (RAG) System}: The platform implements a sophisticated RAG architecture that enhances the quality and accuracy of AI-generated therapeutic responses. By retrieving relevant therapy knowledge from a specialized corpus, the system provides evidence-based therapeutic approaches tailored to user inputs:
    \begin{itemize}
      \item \textbf{Vector Store}: The RAG system utilizes vector embeddings to store and efficiently retrieve therapeutic knowledge with similarity-based search capabilities.
      \item \textbf{PDF Extraction}: The system extracts therapeutic techniques and methodologies from academic and clinical documents such as "Cognitive Therapy: Basics and Beyond" and "The Dialectical Behavior Therapy Skills Workbook."
      \item \textbf{Therapy Approach Selection}: Based on user inputs, the RAG system identifies the most appropriate therapeutic approach (CBT, DBT, or general therapy) with confidence scores, retrieves supporting evidence, and extracts specific therapeutic techniques relevant to the user's situation.
      \item \textbf{Context Enhancement}: The system intelligently merges user history data (journal entries, mood logs) with queries to improve the relevance of therapeutic recommendations.
    \end{itemize}
  
  \item \textbf{Conversation Analysis Engine}: Advanced AI analytics process user-therapist conversations to extract insights, summarize key points, and identify emotional patterns through:
    \begin{itemize}
      \item \textbf{Sentiment Analysis}: Detecting emotional tone in user messages with fine-grained emotion classification (anger, sadness, anxiety, hope, etc.)
      \item \textbf{Topic Modeling}: Identifying recurring themes and concerns using unsupervised learning techniques
      \item \textbf{Summary Generation}: Creating concise summaries of longer conversations with key point extraction and emotional context preservation
      \item \textbf{Conversation History Management}: Implementing intelligent history truncation and summarization to maintain context within token limits
    \end{itemize}
  
  \item \textbf{Predictive AI Services}: The platform incorporates predictive analytics to anticipate user needs and potential issues:
    \begin{itemize}
      \item \textbf{Mood Tracking}: AI-powered analysis of journal entries and interactions to track mood patterns over time using time-series analysis
      \item \textbf{Early Intervention Recommendations}: Identifying potential mental health deterioration signs through linguistic and behavioral markers with configurable alert thresholds
      \item \textbf{Therapeutic Progress Assessment}: Measuring and visualizing progress toward therapeutic goals through multiple metrics
    \end{itemize}
    
  \item \textbf{Social Interaction Analysis}: AI tools that analyze users' social communication patterns to provide insights on:
    \begin{itemize}
      \item \textbf{Communication Style Analysis}: Identifying patterns in how users express themselves using linguistic feature extraction
      \item \textbf{Support Network Evaluation}: Assessing the effectiveness of the user's social support systems through relationship mapping
      \item \textbf{Engagement Metrics}: Measuring user engagement with therapeutic content through sophisticated interaction tracking
    \end{itemize}
    
  \item \textbf{Medication Effect Analysis}: AI-driven analysis of medication impacts based on reported side effects and mood changes, providing valuable insights for therapists through:
    \begin{itemize}
      \item \textbf{Side Effect Recognition}: Identifying potential medication side effects from user-reported symptoms
      \item \textbf{Temporal Pattern Analysis}: Correlating medication intake with mood changes over time
      \item \textbf{Treatment Response Indicators}: Flagging patterns that may indicate positive or negative responses to medication regimens
    \end{itemize}
  
  \item \textbf{Content Safety Framework}: The system incorporates robust content filtering and safety checks through:
    \begin{itemize}
      \item \textbf{Pattern-Based Content Filtering}: Detecting potentially harmful content using specialized regular expression patterns
      \item \textbf{Self-Harm Risk Assessment}: Advanced algorithms for identifying indicators of potential self-harm or crisis situations
      \item \textbf{Ethical Response Generation}: Ensuring appropriate therapeutic responses in sensitive situations with careful prompt engineering
      \item \textbf{Fallback Mechanisms}: Implementing graceful degradation to ensure users always receive support, even when primary AI systems encounter limitations
    \end{itemize}
    
  \item \textbf{Therapy Analysis Engine}: Leverages deep NLP models to analyze therapy session transcripts for adherence to therapeutic modalities and to surface targeted intervention opportunities.
  \item \textbf{Named Entity Recognition & Concept Tagging}: Extracts mental healthâ€“related entities and psychological concepts from user messages and journal entries to enrich context and personalization.
  \item \textbf{Behavioral Pattern Detection}: Machine learning models detect anomalies and emerging trends in user behavior (journal entries, mood logs, activity data) for proactive support.
  \item \textbf{Risk Assessment & Crisis Detection}: AI-driven algorithms continuously evaluate linguistic and behavioral markers to identify elevated self-harm or crisis risk and trigger timely alerts.
  \item \textbf{Adaptive Personalization Module}: Continuously learns from user interactions to adapt conversational style, therapeutic prompts, and content recommendations to individual preferences.
  \item \textbf{AI Orchestration Service}: Coordinates across multiple AI components (conversation summary, RAG, analysis engines) to deliver unified insights and seamless user experiences.
    
  \item \textbf{Modular Service Architecture}: AI components are organized as well-defined, loosely coupled modules within the Django application. Each module exposes clear interfaces, enabling independent development, testing, and future extraction into separate services if needed.
    
  \item \textbf{Asynchronous Processing}: Computationally intensive AI operations run as background tasks using Celery to maintain responsiveness
  \item \textbf{Progressive Enhancement}: The system functions with basic capabilities even when advanced AI features are unavailable
  \item \textbf{Robust Monitoring}: Comprehensive logging and monitoring of AI components performance and behavior
\end{itemize}

This sophisticated design approach facilitates both the current functionality and future enhancements of the AI therapeutic capabilities, allowing for iterative improvement based on user feedback and emerging AI technologies.

\section{Infrastructure and Deployment}

\subsection{Container Architecture}
The system utilizes Docker and Docker Compose for containerization, with two main configuration files:

\begin{itemize}
  \item \textbf{docker-compose.yml}: Standard configuration for development and deployment, including:
    \begin{itemize}
      \item PostgreSQL database service
      \item Redis for caching and message brokering
      \item Django application server
      \item Celery workers for asynchronous tasks
      \item Channels for WebSocket handling
    \end{itemize}
    
  \item \textbf{docker-compose.gpu.yml}: Extended configuration for GPU-accelerated environments, adding:
    \begin{itemize}
      \item GPU device passthrough for AI workloads
      \item Optimized container settings for ML operations
      \item Integration with Ollama for local LLM processing
    \end{itemize}
\end{itemize}

\subsection{Local LLM Integration}
The system integrates with Ollama for local large language model processing:

\begin{itemize}
  \item \textbf{Model Management}:
    \begin{itemize}
      \item Automatic model verification and download via custom Django management commands
      \item Default configuration using the llama2 model
      \item Graceful fallback mechanisms when local processing is unavailable
    \end{itemize}
    
  \item \textbf{Initialization Process}:
    \begin{itemize}
      \item Model presence verification during application startup
      \item Automatic model download if not present
      \item Runtime status monitoring and logging
    \end{itemize}
    
  \item \textbf{Error Handling}:
    \begin{itemize}
      \item Comprehensive error catching for model initialization failures
      \item Detailed logging of setup and runtime issues
      \item Graceful degradation to cloud-based processing when needed
    \end{itemize}
\end{itemize}

\subsection{Environment Configuration}
The system supports flexible deployment configurations through:

\begin{itemize}
  \item \textbf{Database Mode Switching}:
    \begin{itemize}
      \item Custom management command (toggle\_db) for switching between local and cloud databases
      \item Environment-based configuration loading
      \item Automatic connection management
    \end{itemize}
    
  \item \textbf{Environment Variables}:
    \begin{itemize}
      \item Centralized .env file management
      \item Secure credential storage
      \item Runtime configuration options
    \end{itemize}
\end{itemize}

\section{Data Management and Analytics}

\subsection{Database Architecture}
The system employs a multi-layered data management approach:

\begin{itemize}
  \item \textbf{Core Data Models}:
    \begin{itemize}
      \item User profiles (Patient/Therapist)
      \item Appointment scheduling
      \item Messaging and chat history
      \item Journal entries and mood tracking
      \item AI analysis results
    \end{itemize}
    
  \item \textbf{Data Protection}:
    \begin{itemize}
      \item Field-level encryption for sensitive data
      \item GDPR-compliant data handling
      \item Automated data retention policies
    \end{itemize}
\end{itemize}

\subsection{Analytics Implementation}
The analytics system provides insights through:

\begin{itemize}
  \item \textbf{User Analytics}:
    \begin{itemize}
      \item Session engagement metrics
      \item Therapeutic progress tracking
      \item Usage pattern analysis
    \end{itemize}
    
  \item \textbf{System Analytics}:
    \begin{itemize}
      \item Performance monitoring
      \item Error rate tracking
      \item Resource utilization metrics
    \end{itemize}
    
  \item \textbf{Therapeutic Analytics}:
    \begin{itemize}
      \item Treatment effectiveness measures
      \item Engagement correlation analysis
      \item Outcome prediction models
    \end{itemize}
\end{itemize}

\section{Testing and Quality Assurance}

\subsection{Testing Strategy}
The project implements comprehensive testing:

\begin{itemize}
  \item \textbf{Unit Tests}:
    \begin{itemize}
      \item Model validation
      \item Service function testing
      \item API endpoint verification
    \end{itemize}
    
  \item \textbf{Integration Tests}:
    \begin{itemize}
      \item End-to-end workflow testing
      \item WebSocket communication
      \item AI service integration
    \end{itemize}
    
  \item \textbf{Performance Tests}:
    \begin{itemize}
      \item Load testing
      \item Scalability verification
      \item Response time benchmarking
    \end{itemize}
\end{itemize}

\subsection{Quality Metrics}
Quality is ensured through:

\begin{itemize}
  \item \textbf{Code Quality}:
    \begin{itemize}
      \item Automated linting (ruff)
      \item Code formatting standards
      \item Documentation requirements
    \end{itemize}
    
  \item \textbf{Performance Standards}:
    \begin{itemize}
      \item Response time thresholds
      \item Resource usage limits
      \item Scalability benchmarks
    \end{itemize}
    
  \item \textbf{Security Standards}:
    \begin{itemize}
      \item Regular security audits
      \item Dependency vulnerability scanning
      \item Compliance verification
    \end{itemize}
\end{itemize}
